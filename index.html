<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dist Castillo Ventas</title>
    <!-- Ruta relativa para manifest.json -->
    <link rel="manifest" href="./manifest.json">
    <!-- Carga de Tailwind CSS desde CDN para asegurar que el estilo se aplique correctamente -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
    <!-- html2canvas para convertir HTML a imagen -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            background-image: url('./images/fondo.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            background-color: rgba(0, 0, 0, 0.1);
        }
        #app-root {
            width: 100%;
            max-width: 800px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            padding: 20px;
        }
        .screen-container {
            padding: 0px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: rgba(255, 255, 255, 0.98);
            padding: 35px;
            border-radius: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 600px;
            max-height: 90%;
            overflow-y: auto;
            text-align: center;
        }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
        }
        .table-container {
            overflow-x: auto;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 8px 10px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }
        th {
            background-color: #f8fafc;
            font-weight: 600;
            color: #4a5568;
            text-transform: uppercase;
            font-size: 0.875rem;
            letter-spacing: 0.05em;
        }
        tr:hover {
            background-color: #f0f4f8;
        }
        td input[type="number"] {
            width: 80px;
            padding: 6px 10px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            text-align: center;
        }
        .radio-button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .radio-button-label {
            background-color: #e3f2fd;
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #1976d2;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-weight: 500;
            color: #1976d2;
            text-align: center;
        }
        .radio-button-label:hover {
            background-color: #bbdefb;
        }
        .radio-button-input:checked + .radio-button-label {
            background-color: #1976d2;
            color: white;
            border-color: #0d47a1;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .radio-button-input {
            display: none;
        }
        .thermal-receipt {
            font-family: 'monospace', 'Courier New', Courier, monospace;
            font-size: 0.75rem;
            width: 250px;
            margin: 0 auto;
            padding: 10px;
            border: 1px dashed #ccc;
            background-color: #fff;
            color: #000;
            text-align: left;
            box-shadow: 0 0 5px rgba(0,0,0,0.1);
        }
        .thermal-receipt h3, .thermal-receipt h4 {
            text-align: center;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }
        .thermal-receipt .item-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }
        .thermal-receipt .item-qty {
            width: 20%;
            text-align: left;
        }
        .thermal-receipt .item-desc {
            width: 50%;
            text-align: left;
        }
        .thermal-receipt .item-price, .item-total {
            width: 30%;
            text-align: right;
        }
        .thermal-receipt .divider {
            border-top: 1px dashed #000;
            margin: 5px 0;
        }
        .thermal-receipt .total-line {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            margin-top: 5px;
            font-size: 0.9rem;
        }
        .thermal-receipt .footer-text {
            text-align: center;
            margin-top: 10px;
            font-size: 0.7rem;
        }
        @media print {
            body > *:not(.print-only) {
                display: none !important;
            }
            .print-only {
                display: block !important;
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: auto;
                margin: 0;
                padding: 0;
            }
            .thermal-receipt {
                border: none !important;
                box-shadow: none !important;
                width: 100% !important;
                font-size: 10pt;
            }
        }
    </style>
</head>
<body>
    <div id="app-root"></div>

    <script defer type="module">
        console.log('[App Init] Script started.');

        // Importar módulos
        import * as clientManagement from './clientManagement.js';
        import * as inventoryManagement from './inventoryManagement.js';

        // --- Datos de la aplicación (se cargarán desde Firestore) ---
        // Estas variables ahora son gestionadas por inventoryManagement y clientManagement
        // Pero se mantienen aquí para ser pasadas por referencia o para datos no específicos de un módulo
        let inventory = []; // Passed to inventoryManagement
        let vendors = [];
        let vehicles = []; // Passed to inventoryManagement
        let users = [];
        let dailySales = []; // Sales are still managed here for now

        let selectedVendor = localStorage.getItem('selectedVendor') || 'Ninguno'; // Default to 'Ninguno' if no vendors initially

        const productImages = {
            '2364': './images/2364.png',
            '7458': './images/7458.png',
            '1001': './images/1001.png',
            '1002': './images/1002.png',
            '9876': './images/9876.png',
            'default': './images/no-image.png'
        };

        // --- Estado Global de la Aplicación ---
        let screen = 'login';
        let saleQuantities = {};
        let currentProductIndex = 0;
        let showMessageModalState = false;
        let messageModalText = '';
        let showConfirmationModalState = false;
        let confirmationModalMessage = '';
        let confirmationModalCallback = null;
        let currentUser = null;
        let currentUserData = { role: 'guest', assignedTruckPlate: null };
        const appRoot = document.getElementById('app-root');
        let showModifySaleModalState = false;
        let selectedSaleForModification = null;
        let modifiedSaleQuantities = {};
        let modificationReason = '';
        // let editingVehicle = null; // This is now managed by inventoryManagement, but still a local variable for now.

        // --- Funciones de Rol ---
        const isAdmin = () => currentUserData.role === 'admin';
        const isUser = () => currentUserData.role === 'user';

        // --- Componentes Reutilizables de UI (Globales) ---
        const createScreenContainer = (title, content, className = '') => `
            <div class="screen-container bg-white rounded-xl m-2 shadow-md ${className}">
                <h2 class="text-2xl font-bold mb-5 text-center text-indigo-700">${title}</h2>
                ${content}
            </div>
        `;

        const createButton = (text, id, className = '', dataAttributes = {}) => {
            const dataAttrs = Object.keys(dataAttributes).map(key => `data-${key}="${dataAttributes[key]}"`).join(' ');
            return `<button id="${id}" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-6 rounded-lg m-2 min-w-[150px] shadow-md transition duration-300 ease-in-out transform hover:scale-105 border border-indigo-700 ${className}" ${dataAttrs}>${text}</button>`;
        };

        const createInput = (id, placeholder, value = '', type = 'text', disabled = false, className = '', dataAttributes = {}) => {
            const dataAttrs = Object.keys(dataAttributes).map(key => `data-${key}="${dataAttributes[key]}"`).join(' ');
            return `<input type="${type}" id="${id}" class="h-12 border border-gray-300 rounded-lg px-4 mb-4 text-base w-full bg-white focus:ring-2 focus:ring-indigo-500 focus:border-transparent ${className}" placeholder="${placeholder}" value="${value}" ${disabled ? 'disabled' : ''} ${dataAttrs}>`;
        };

        const createSelect = (id, options, selectedValue, className = '', placeholder = '-- Seleccione --', dataAttributes = {}) => {
            const dataAttrs = Object.keys(dataAttributes).map(key => `data-${key}="${dataAttributes[key]}"`).join(' ');
            return `
                <select id="${id}" class="h-12 border border-gray-300 rounded-lg px-4 text-base w-full bg-white focus:ring-2 focus:ring-blue-500 focus:border-transparent ${className}" ${dataAttrs}>
                    <option value="">${placeholder}</option>
                    ${options.map(opt => `<option value="${opt.value}" ${selectedValue === opt.value ? 'selected' : ''}>${opt.text}</option>`).join('')}
                </select>
            `;
        };

        const createTable = (headers, rowsHtml, id = '') => `
            <div class="table-container mb-5">
                <table>
                    <thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>
                    <tbody id="${id}">${rowsHtml}</tbody>
                </table>
            </div>
        `;

        // --- Funciones de Modales (Globales) ---
        const showMessageModal = (message) => {
            messageModalText = message;
            showMessageModalState = true;
            render();
        };
        // Expose to window for clientManagement.js to use
        window.showMessageModal = showMessageModal;

        const hideMessageModal = () => {
            showMessageModalState = false;
            messageModalText = '';
            render();
        };

        const renderMessageModal = () => {
            if (!showMessageModalState) return '';
            return `
                <div id="custom-message-modal" class="modal">
                    <div class="modal-content">
                        <p class="text-lg text-center mb-4">${messageModalText}</p>
                        <button id="messageModalCloseButton" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105">Cerrar</button>
                    </div>
                </div>
            `;
        };

        const showConfirmationModal = (message, callback) => {
            confirmationModalMessage = message;
            confirmationModalCallback = callback;
            showConfirmationModalState = true;
            render();
        };
        // Expose to window for clientManagement.js to use
        window.showConfirmationModal = showConfirmationModal;


        const hideConfirmationModal = (confirmed) => {
            showConfirmationModalState = false;
            if (confirmed && confirmationModalCallback) {
                confirmationModalCallback();
            }
            confirmationModalCallback = null;
            render();
        };

        const renderConfirmationModal = () => {
            if (!showConfirmationModalState) return '';
            return `
                <div id="confirmation-modal" class="modal">
                    <div class="modal-content">
                        <p class="text-lg text-center mb-6">${confirmationModalMessage}</p>
                        <div class="flex justify-around gap-4">
                            <button id="confirmationModalConfirmButton" class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-5 rounded-lg flex-1 shadow-md transition duration-300 ease-in-out transform hover:scale-105">Confirmar</button>
                            <button id="confirmationModalCancelButton" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-5 rounded-lg flex-1 shadow-md transition duration-300 ease-in-out transform hover:scale-105">Cancelar</button>
                        </div>
                    </div>
                </div>
            `;
        };

        // --- Funciones de Ayuda Generales ---
        const getCurrentDateFormatted = () => {
            const today = new Date();
            const day = String(today.getDate()).padStart(2, '0');
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const year = today.getFullYear();
            return `${day}${month}${year}`;
        };

        const triggerCSVDownload = (filename, csvContent) => {
            if (!csvContent) {
                showMessageModal(`No se encontró contenido para descargar el archivo: ${filename}`);
                return;
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            } else {
                showMessageModal('La descarga de archivos no es compatible con este navegador.');
            }
        };

        const parseCSV = (csvString) => {
            const lines = csvString.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) return [];
            const headers = lines[0].split(',').map(header => header.trim());
            return lines.slice(1).map(currentLine => {
                const data = currentLine.split(',');
                return headers.reduce((obj, header, j) => {
                    obj[header] = data[j] ? data[j].trim() : '';
                    return obj;
                }, {});
            });
        };

        const toCSV = (data, headers) => {
            if (!data || data.length === 0) return '';
            const actualHeaders = headers || Object.keys(data[0]);
            const csvRows = [actualHeaders.map(header => {
                const val = header;
                if (typeof val === 'string' && (val.includes(',') || val.includes('"') || val.includes('\n'))) {
                    return `"${val.replace(/"/g, '""')}"`;
                }
                return val;
            }).join(',')];
            for (const row of data) {
                const values = actualHeaders.map(header => {
                    const val = row[header];
                    if (typeof val === 'string' && (val.includes(',') || val.includes('"') || val.includes('\n'))) {
                        return `"${val.replace(/"/g, '""')}"`;
                    }
                    return typeof val === 'number' ? val.toString() : val;
                });
                csvRows.push(values.join(','));
            }
            return csvRows.join('\n');
        };


        // --- Funciones de Pantalla (Globales) ---
        const setScreenAndRender = (newScreen) => {
            console.log(`[setScreenAndRender] Changing screen to: ${newScreen}`);
            // Store the current screen in a data attribute for `_setScreenAndRender` in modules
            appRoot.dataset.currentScreen = newScreen;

            // Clean up admin truck inventory listener if navigating away from admin inventory screens
            if (inventoryManagement.adminTruckInventoryUnsubscribe && newScreen !== 'adminVehicleInventory') {
                inventoryManagement.adminTruckInventoryUnsubscribe();
                inventoryManagement.adminTruckInventoryUnsubscribe = null;
                console.log('[Firestore Listener] Unsubscribed from admin truck inventory listener due to screen change.');
            }
            // Clean up client-related modals if navigating away from client screen or sales screen
            if (newScreen !== 'clientes' && newScreen !== 'venta') {
                clientManagement.closeAllClientModals();
            }
            screen = newScreen;
            render();
        };

        const render = () => {
            console.log(`[Render] Current screen to render: ${screen}`);
            appRoot.innerHTML = ''; // Clear existing content

            const screenFunctions = {
                'main': renderMainScreen,
                'cargaSelection': inventoryManagement.renderCargaSelectionScreen,
                'truckLoading': inventoryManagement.renderTruckReceivingScreen,
                'loadHistory': inventoryManagement.renderLoadHistoryScreen,
                'inventario': inventoryManagement.renderInventarioScreen,
                'clientes': clientManagement.renderClientesScreen,
                'venta': renderVentaScreen,
                'cierreVentas': renderCierreVentasScreen,
                'archivosAdmin': renderArchivosAdminScreen,
                'archivosVenta': renderArchivosVentaScreen,
                'vehicles': inventoryManagement.renderVehiclesScreen,
                'adminInventorySelection': inventoryManagement.renderAdminInventorySelection,
                'adminMainInventory': inventoryManagement.renderAdminMainInventoryScreen,
                'adminVehicleInventory': inventoryManagement.renderAdminVehicleInventoryScreen,
                'assignVehicle': inventoryManagement.renderAssignVehicleScreen,
                'login': renderLoginScreen,
                'register': renderRegisterScreen,
                'resetCargasInicialesPassword': inventoryManagement.renderResetCargasInicialesPasswordScreen,
                'resetCargasInicialesEdit': inventoryManagement.renderResetCargasInicialesEditScreen,
                'transferInventoryPassword': inventoryManagement.renderTransferInventoryPasswordScreen,
                'transferInventory': inventoryManagement.renderTransferInventoryScreen,
                'adminTransferHistory': inventoryManagement.renderAdminTransferHistoryScreen,
            };

            if (!currentUser && screen !== 'login' && screen !== 'register') {
                console.log('[Render] No current user, forcing login screen.');
                renderLoginScreen();
            } else {
                (screenFunctions[screen] || renderMainScreen)();
            }

            appRoot.innerHTML += renderMessageModal();
            appRoot.innerHTML += renderConfirmationModal();
            if (showModifySaleModalState) appRoot.innerHTML += renderModifySaleModal();
            clientManagement.renderEditClientModal(); // Render client modals
            clientManagement.renderManageZonesSectorsModal();
            clientManagement.renderClientPickerModal();
            console.log('[Render] Render cycle completed.');

            if (clientManagement.showManageZonesSectorsModalState) {
                clientManagement.updateManageZonesSectorsModalContent();
            }
            if (clientManagement.showClientPickerModal) {
                clientManagement.updateClientPickerList();
            }
        };

        // --- Definición de todas las pantallas ---
        const renderLoginScreen = () => {
            console.log('[renderLoginScreen] Rendering login screen.');
            appRoot.innerHTML = createScreenContainer('Iniciar Sesión', `
                ${createInput('loginEmail', 'Correo Electrónico', '', 'email')}
                ${createInput('loginPassword', 'Contraseña', '', 'password')}
                ${createButton('Iniciar Sesión', 'loginButton', 'w-full')}
                <p class="text-center mt-6 text-gray-700">¿No tienes cuenta? <a href="#" id="registerLink" class="text-indigo-600 hover:underline font-semibold">Regístrate aquí</a></p>
            `, 'max-w-md mx-auto my-10');
        };

        const renderRegisterScreen = () => {
            console.log('[renderRegisterScreen] Rendering register screen.');
            appRoot.innerHTML = createScreenContainer('Registrar Nuevo Usuario', `
                ${createInput('registerEmail', 'Correo Electrónico', '', 'email')}
                ${createInput('registerPassword', 'Contraseña', '', 'password')}
                ${createButton('Registrar', 'registerButton', 'w-full')}
                <p class="text-center mt-6 text-gray-700">¿Ya tienes cuenta? <a href="#" id="loginLink" class="text-indigo-600 hover:underline font-semibold">Inicia sesión aquí</a></p>
            `, 'max-w-md mx-auto my-10');
        };

        const renderMainScreen = () => {
            console.log('[renderMainScreen] Rendering main screen.');
            const buttons = [
                isAdmin() && createButton('CARGA', 'cargaSelectionButton'),
                isAdmin() && createButton('INVENTARIO', 'adminInventorySelectionButton'),
                isUser() && createButton('INVENTARIO', 'userInventoryButton'),
                createButton('CLIENTES', 'clientsButton'),
                isUser() && createButton('VENTA', 'ventaButton'),
                isUser() && createButton('CIERRE VENTAS', 'cierreVentasButton'),
                isAdmin() && createButton('ARCHIVOS ADMIN', 'archivosAdminButton'),
                !isAdmin() && currentUser && createButton('ARCHIVOS DE VENTA', 'archivosVentaButton'),
                isAdmin() && createButton('VEHÍCULOS DE CARGA', 'vehiclesButton'),
                isAdmin() && createButton('ASIGNAR VEHÍCULO', 'assignVehicleButton'),
                isUser() && createButton('TRANSBORDO INV.', 'transferInventoryPasswordButton'),
                isAdmin() && createButton('HISTORIAL TRANSBORDOS', 'adminTransferHistoryButton'),
            ].filter(Boolean).join('');

            appRoot.innerHTML = `
                <div class="flex flex-col items-center justify-center p-5 bg-blue-50 rounded-xl m-2 shadow-lg">
                    <h1 class="text-3xl font-bold mb-4 text-indigo-700 drop-shadow-sm">Dist Castillo Ventas</h1>
                    ${currentUser ? `<p class="text-md text-gray-700 mb-4">Bienvenido, ${currentUser.email} (${currentUserData.role}) ${currentUserData.assignedTruckPlate ? ` - Camión: ${currentUserData.assignedTruckPlate}` : ''}</p>` : ''}
                    <div class="flex flex-wrap justify-center">${buttons}</div>
                    ${createButton('Cerrar Sesión', 'logoutButton', 'bg-red-600 mt-8 w-full')}
                </div>
            `;
        };

        const updateVendorSelectionDisplay = () => {
            const vendorRadioGroup = document.getElementById('vendor-radio-group');
            if (!vendorRadioGroup) return;
            vendorRadioGroup.innerHTML = vendors.map(vendor => `
                <input type="radio" id="vendor-${vendor.name.replace(/\s/g, '-')}" name="vendor" value="${vendor.name}" class="radio-button-input" ${selectedVendor === vendor.name ? 'checked' : ''}>
                <label for="vendor-${vendor.name.replace(/\s/g, '-')}" class="radio-button-label">${vendor.name}</label>
            `).join('');
        };

        const handleVendorChange = (vendorName) => {
            selectedVendor = vendorName;
            localStorage.setItem('selectedVendor', selectedVendor);
        };

        const renderVentaScreen = () => {
            console.log('[renderVentaScreen] Rendering venta screen.');
            appRoot.innerHTML = createScreenContainer('VENTA', `
                ${createButton('Seleccionar Cliente', 'selectClientButton', 'bg-purple-600')}
                <div id="selected-client-display" class="text-lg font-bold text-center my-4 text-emerald-800"></div>
                <div id="product-sale-container"></div>
                <div id="info-text" class="text-base text-center my-5 text-gray-600"></div>
                ${createButton('Volver al Menú Principal', 'resetVentaStateAndGoToMainButton', 'bg-gray-600 mt-5 w-full')}
            `);
            updateVentaScreenContent();
        };

        const updateVentaScreenContent = () => {
            console.log('[updateVentaScreenContent] Updating venta screen content.');
            const selectedClientDisplay = document.getElementById('selected-client-display');
            const productSaleContainer = document.getElementById('product-sale-container');
            const infoText = document.getElementById('info-text');

            if (isUser() && !currentUserData.assignedTruckPlate) {
                selectedClientDisplay.textContent = '';
                infoText.textContent = 'No tienes un camión asignado. Por favor, contacta a un administrador para que te asigne uno.';
                productSaleContainer.innerHTML = '';
                return;
            }

            // Use the getter function to access currentTruckInventory
            const inventoryToDisplay = currentUserData.assignedTruckPlate ? inventoryManagement.getCurrentTruckInventory() : inventory;
            const inventorySourceText = currentUserData.assignedTruckPlate ? ` (Camión: ${currentUserData.assignedTruckPlate})` : ' (Almacén Principal)';

            if (clientManagement.selectedClientForSale) {
                selectedClientDisplay.textContent = `Cliente Seleccionado: ${clientManagement.selectedClientForSale.nombreComercial}`;
                infoText.textContent = `Inventario actual${inventorySourceText}`;

                const tableRows = inventoryToDisplay.map(item => {
                    const quantity = item.quantity !== undefined ? item.quantity : item.cantidad;
                    const price = item.price !== undefined ? item.price : item.precio;
                    return `
                        <td><img src="${productImages[item.sku] || productImages['default']}" alt="Imagen de ${item.producto}" class="w-10 h-10 rounded-md object-cover"></td>
                        <td>${item.sku}</td>
                        <td><input type="number" class="border border-gray-300 rounded-md text-center sale-quantity-input" value="${saleQuantities[item.sku] || ''}" data-sku="${item.sku}" min="0" max="${quantity}"></td>
                        <td>${item.producto}</td><td>${item.presentacion}</td><td>$${price.toFixed(2)}</td><td>${quantity}</td>
                    `;
                }).map(row => `<tr>${row}</tr>`).join('');

                productSaleContainer.innerHTML = `
                    ${createTable(['Imagen', 'SKU', 'Cantidad a Vender', 'Producto', 'Presentación', 'Precio', 'Disponible'], tableRows, 'products-for-sale-body')}
                    ${createButton('Finalizar Venta', 'finalizeSaleButton', 'bg-emerald-600 mt-3 w-full')}
                `;
            } else {
                selectedClientDisplay.textContent = '';
                infoText.textContent = 'Por favor, seleccione un cliente para iniciar la venta.';
                productSaleContainer.innerHTML = '';
            }
        };

        const handleProductQuantityChange = (sku, quantity) => {
            saleQuantities[sku] = parseInt(quantity) || 0;
        };

        const showFinalizeSaleConfirmation = () => {
            showConfirmationModal('¿Estás seguro de que quieres finalizar esta venta? Esto actualizará el inventario y generará un archivo de venta.', finalizeSaleLogic);
        };

        const finalizeSaleLogic = async () => {
            if (!clientManagement.selectedClientForSale) { showMessageModal('Error: Por favor, seleccione un cliente primero.'); return; }
            if (isUser() && !currentUserData.assignedTruckPlate) { showMessageModal('Error: No tienes un camión asignado para realizar ventas.'); return; }

            const saleData = [];
            let totalSaleAmount = 0;
            let messages = [];
            let validationErrors = [];

            const sourceInventoryCollection = currentUserData.assignedTruckPlate ? 'truck_inventories' : 'inventory';
            const sourceInventoryDocId = currentUserData.assignedTruckPlate;

            let currentSourceInventoryData;
            if (sourceInventoryDocId) {
                // Use the getter function
                currentSourceInventoryData = JSON.parse(JSON.stringify(inventoryManagement.getCurrentTruckInventory()));
            } else {
                currentSourceInventoryData = JSON.parse(JSON.stringify(inventory));
            }

            let updatedSourceInventory = JSON.parse(JSON.stringify(currentSourceInventoryData));

            for (const item of currentSourceInventoryData) {
                const quantitySold = saleQuantities[item.sku] || 0;
                const availableQuantity = item.quantity !== undefined ? item.quantity : item.cantidad;

                if (quantitySold > 0) {
                    if (quantitySold > availableQuantity) {
                        validationErrors.push(`Error: La cantidad a vender de "${item.producto}" (${quantitySold}) excede el stock disponible (${availableQuantity}).`);
                    } else {
                        const price = item.price !== undefined ? item.price : item.precio;
                        const subtotal = quantitySold * price;
                        saleData.push({ sku: item.sku, producto: item.producto, presentacion: item.presentacion, cantidadVendida: quantitySold, precioUnitario: price, subtotal: subtotal });
                        totalSaleAmount += subtotal;

                        updatedSourceInventory = updatedSourceInventory.map(invItem =>
                            invItem.sku === item.sku ? {
                                ...invItem,
                                quantity: (invItem.quantity !== undefined ? invItem.quantity : invItem.cantidad) - quantitySold,
                                cantidad: (invItem.quantity !== undefined ? invItem.quantity : invItem.cantidad) - quantitySold
                            } : invItem
                        );
                    }
                }
            }

            if (validationErrors.length > 0) { showMessageModal(validationErrors.join('\n')); return; }
            if (saleData.length === 0) { showMessageModal('Error: No se ha ingresado ninguna cantidad para la venta.'); return; }

            const fileName = `venta_${clientManagement.selectedClientForSale.nombreComercial.replace(/\s/g, '_')}_${getCurrentDateFormatted()}.csv`;
            const saleRecord = {
                fileName: fileName, client: clientManagement.selectedClientForSale, date: getCurrentDateFormatted(), items: saleData,
                total: totalSaleAmount, vendor: selectedVendor, sourceInventory: currentUserData.assignedTruckPlate || 'warehouse',
                rawCSV: `SKU,Producto,Presentacion,Cantidad,Precio Unitario,Subtotal\n` +
                        saleData.map(item => `${item.sku},${item.producto},${item.presentacion},${item.cantidadVendida},${item.precioUnitario.toFixed(2)},${item.subtotal.toFixed(2)}`).join('\n') +
                        `\nTotal General:, , , , ,${totalSaleAmount.toFixed(2)}`
            };

            saleRecord.docId = `temp_${Date.now()}`;
            dailySales.push(saleRecord);

            if (sourceInventoryDocId) {
                // Use the setter function
                inventoryManagement.setCurrentTruckInventory(updatedSourceInventory.filter(item => (item.quantity !== undefined ? item.quantity : item.cantidad) > 0));
            }

            resetVentaState();
            setScreenAndRender('main');
            showMessageModal(`Venta registrada localmente para ${clientManagement.selectedClientForSale.nombreComercial}. Se sincronizará cuando haya conexión a internet.`);

            try {
                const batch = db.batch();
                const docRef = db.collection('dailySales').doc();
                batch.set(docRef, saleRecord);

                if (sourceInventoryDocId) {
                    batch.set(db.collection('truck_inventories').doc(sourceInventoryDocId), { items: inventoryManagement.getCurrentTruckInventory() }); // Use getter here
                }

                await batch.commit();
                console.log('Firestore commit successful for sale:', saleRecord.fileName);

                const index = dailySales.findIndex(s => s.docId === saleRecord.docId);
                if (index !== -1) {
                    dailySales[index].docId = docRef.id;
                }
                await fetchDataFromFirestore();

            } catch (error) {
                console.error('Error al guardar la venta en Firestore (puede ser por falta de conexión):', error);
                if (error.code !== 'unavailable' && error.code !== 'internal' && error.code !== 'failed-precondition') {
                    showMessageModal('Error al guardar la venta en la nube. Por favor, revisa tu conexión y las reglas de seguridad de Firestore.');
                }
            }
        };

        const resetVentaState = () => {
            clientManagement.resetSelectedClientForSale();
            saleQuantities = {};
            currentProductIndex = 0;
        };

        const resetVentaStateAndGoToMain = () => {
            resetVentaState();
            setScreenAndRender('main');
        };

        const renderCierreVentasScreen = () => {
            appRoot.innerHTML = createScreenContainer('CIERRE DE VENTAS', `
                <div class="mb-8 text-center">
                    <label class="block text-lg font-semibold text-gray-700 mb-2">Seleccionar Vendedor:</label>
                    <div class="radio-button-group" id="vendor-radio-group"></div>
                </div>
                <p class="text-base text-center my-5 text-gray-600">Esta sección permite consolidar y cerrar las ventas del día.</p>
                ${createButton('Cerrar Ventas del Día', 'closeSalesButton', 'bg-emerald-600 mt-3 w-full')}
                ${createButton('Volver', 'backToMainFromCierreVentasButton', 'bg-gray-600 mt-5 w-full')}
            `);
            updateVendorSelectionDisplay();
        };

        const showCloseSalesConfirmation = () => {
            showConfirmationModal('¿Estás seguro de que quieres cerrar las ventas del día? Esto consolidará las ventas y "borrará" los registros individuales.', handleCloseSalesLogic);
        };

        const handleCloseSalesLogic = async () => {
            console.log('[handleCloseSalesLogic] Initiating sales close logic.');

            if (!navigator.onLine) {
                showMessageModal('Error de Conexión: No se puede realizar el cierre de ventas sin conexión a internet. Por favor, verifica tu conexión y vuelve a intentarlo.');
                console.warn('[handleCloseSalesLogic] Aborting sales closure due to no internet connection.');
                return;
            }

            let messages = [];
            if (dailySales.length === 0) {
                showMessageModal('No hay Ventas: No hay ventas registradas para cerrar.');
                console.log('[handleCloseSalesLogic] No daily sales found.');
                return;
            }

            const salesByDate = dailySales.reduce((acc, sale) => {
                (acc[sale.date] = acc[sale.date] || []).push(sale);
                return acc;
            }, {});

            let allProcessedSaleDocIds = [];
            let updatedMainInventory = JSON.parse(JSON.stringify(inventory));
            console.log('[handleCloseSalesLogic] Initial Main Inventory (before processing sales):', JSON.stringify(updatedMainInventory.map(i => ({sku: i.sku, cantidad: i.cantidad}))));

            const truckSalesAggregates = {};

            for (const date in salesByDate) {
                const salesForThisDate = salesByDate[date];
                const aggregatedSalesBySku = {};
                let totalOverallSale = 0;

                salesForThisDate.forEach(sale => {
                    sale.items.forEach(item => {
                        const { sku, producto, presentacion, cantidadVendida, precioUnitario, subtotal } = item;
                        if (!aggregatedSalesBySku[sku]) {
                            aggregatedSalesBySku[sku] = { producto, presentacion, totalCantidad: 0, totalSubtotal: 0 };
                        }
                        aggregatedSalesBySku[sku].totalCantidad += cantidadVendida;
                        aggregatedSalesBySku[sku].totalSubtotal += subtotal;
                        totalOverallSale += subtotal;
                    });

                    if (sale.sourceInventory && sale.sourceInventory !== 'warehouse') {
                        const truckPlate = sale.sourceInventory;
                        if (!truckSalesAggregates[truckPlate]) {
                            truckSalesAggregates[truckPlate] = {};
                        }
                        sale.items.forEach(item => {
                            truckSalesAggregates[truckPlate][item.sku] = (truckSalesAggregates[truckPlate][item.sku] || 0) + item.cantidadVendida;
                        });
                    }
                });

                let combinedCSVContent = `Venta General Consolidada - Fecha: ${date}\nVendedor: ${selectedVendor}\n\nSKU,Producto,Presentacion,Cantidad Total,Subtotal Total\n`;
                for (const sku in aggregatedSalesBySku) {
                    const item = aggregatedSalesBySku[sku];
                    combinedCSVContent += `${sku},${item.producto},${item.presentacion},${item.totalCantidad},${item.totalSubtotal.toFixed(2)}\n`;
                }
                combinedCSVContent += `\nTotal General:, , , ,${totalOverallSale.toFixed(2)}`;
                const combinedFileName = `venta_consolidada_${date}.csv`;
                messages.push(`Cierre de Ventas para ${date}: Se ha generado el archivo "${combinedFileName}" con las ventas consolidadas.\nTotal del día: $${totalOverallSale.toFixed(2)}`);
                console.log(`[handleCloseSalesLogic] Attempting to download consolidated CSV: ${combinedFileName}`);
                triggerCSVDownload(combinedFileName, combinedCSVContent);

                const uniqueSKUs = new Set();
                const clientSalesData = {};
                salesForThisDate.forEach(sale => {
                    if (!clientSalesData[sale.client.id]) {
                        clientSalesData[sale.client.id] = { clientName: sale.client.nombreComercial, total: 0, skus: {} };
                    }
                    sale.items.forEach(item => {
                        uniqueSKUs.add(item.sku);
                        clientSalesData[sale.client.id].skus[item.sku] = (clientSalesData[sale.client.id].skus[item.sku] || 0) + item.cantidadVendida;
                        clientSalesData[sale.client.id].total += item.subtotal;
                    });
                });

                const sortedUniqueSKUs = Array.from(uniqueSKUs).sort();
                let clientCSVContent = `Venta General por Clientes - Fecha: ${date}\nVendedor: ${selectedVendor}\n\nCliente,${sortedUniqueSKUs.map(sku => `SKU(${sku})`).join(',')},Total\n`;
                let grandTotalClients = 0;
                for (const clientId in clientSalesData) {
                    const clientData = clientSalesData[clientId];
                    let clientRow = `"${clientData.clientName}"`;
                    sortedUniqueSKUs.forEach(sku => { clientRow += `,${clientData.skus[sku] || 0}`; });
                    clientRow += `,${clientData.total.toFixed(2)}\n`;
                    clientCSVContent += clientRow;
                    grandTotalClients += clientData.total;
                }
                clientCSVContent += `Total General:,${','.repeat(sortedUniqueSKUs.length)},${grandTotalClients.toFixed(2)}`;
                const clientFileName = `ventas_por_cliente_${date}.csv`;
                messages.push(`Se ha generado el archivo "${clientFileName}" con las ventas consolidadas por cliente para ${date}.`);
                console.log(`[handleCloseSalesLogic] Attempting to download client-specific CSV: ${clientFileName}`);
                triggerCSVDownload(clientFileName, clientCSVContent);

                for (const sku in aggregatedSalesBySku) {
                    const totalQuantitySold = aggregatedSalesBySku[sku].totalCantidad;
                    const mainInventoryItem = updatedMainInventory.find(item => item.sku === sku);
                    if (mainInventoryItem) {
                        console.log(`[handleCloseSalesLogic] Deducting ${totalQuantitySold} of SKU ${sku} from main inventory. Before: ${mainInventoryItem.cantidad}`);
                        mainInventoryItem.cantidad = Math.max(0, mainInventoryItem.cantidad - totalQuantitySold);
                        console.log(`[handleCloseSalesLogic] After deduction: ${mainInventoryItem.cantidad}`);
                    } else {
                        messages.push(`Advertencia: SKU ${sku} vendido no encontrado en el inventario principal para deducción durante el cierre.`);
                        console.warn(`[handleCloseSalesLogic] SKU ${sku} not found in main inventory for deduction.`);
                    }
                }
                salesForThisDate.forEach(sale => {
                    if (sale.docId) {
                        allProcessedSaleDocIds.push(sale.docId);
                        console.log(`[handleCloseSalesLogic] Marking sale DOC ID ${sale.docId} for deletion.`);
                    }
                });
            }

            console.log('[handleCloseSalesLogic] Main Inventory AFTER processing sales (before commit):', JSON.stringify(updatedMainInventory.map(i => ({sku: i.sku, cantidad: i.cantidad}))));

            messages.push(`Compartiendo: Simulando compartir archivos de cierre vía WhatsApp.`);
            messages.push(`Imprimiendo: Simulando impresión del cierre de ventas.`);

            try {
                const batch = db.batch();
                updatedMainInventory.forEach(item => {
                    console.log(`[handleCloseSalesLogic] Adding batch set for main inventory SKU: ${item.sku}, new quantity: ${item.cantidad}`);
                    batch.set(db.collection('inventory').doc(item.sku), {
                        rubro: item.rubro,
                        sku: item.sku,
                        segmento: item.segmento,
                        producto: item.producto,
                        presentacion: item.presentacion,
                        cantidad: item.cantidad,
                        precio: item.precio
                    });
                });
                inventory.splice(0, inventory.length, ...updatedMainInventory.filter(item => item.cantidad > 0)); // Update in place
                console.log('[handleCloseSalesLogic] Local main inventory updated to:', JSON.stringify(inventory.map(i => ({sku: i.sku, cantidad: i.cantidad}))));

                for (const date in salesByDate) {
                    const salesForThisDate = salesByDate[date];
                    const aggregatedSalesBySku = {};
                    let totalOverallSale = 0;
                    salesForThisDate.forEach(sale => {
                        sale.items.forEach(item => {
                            const { sku, producto, presentacion, cantidadVendida, precioUnitario, subtotal } = item;
                            if (!aggregatedSalesBySku[sku]) {
                                aggregatedSalesBySku[sku] = { producto, presentacion, totalCantidad: 0, totalSubtotal: 0 };
                            }
                            aggregatedSalesBySku[sku].totalCantidad += cantidadVendida;
                            aggregatedSalesBySku[sku].totalSubtotal += subtotal;
                            totalOverallSale += subtotal;
                        });
                    });

                    const itemsSoldSummary = [];
                    for (const sku in aggregatedSalesBySku) {
                        const item = aggregatedSalesBySku[sku];
                        itemsSoldSummary.push({
                            sku: sku,
                            producto: item.producto,
                            presentacion: item.presentacion,
                            totalCantidad: item.totalCantidad,
                            totalSubtotal: item.totalSubtotal
                        });
                    }

                    const combinedCSVContent = `Venta General Consolidada - Fecha: ${date}\nVendedor: ${selectedVendor}\n\nSKU,Producto,Presentacion,Cantidad Total,Subtotal Total\n` +
                                               Object.keys(aggregatedSalesBySku).map(sku => {
                                                   const item = aggregatedSalesBySku[sku];
                                                   return `${sku},${item.producto},${item.presentacion},${item.totalCantidad},${item.totalSubtotal.toFixed(2)}`;
                                               }).join('\n') +
                                               `\nTotal General:, , , ,${totalOverallSale.toFixed(2)}`;

                    const generalSaleDocRef = db.collection('historicalConsolidatedGeneralSales').doc();
                    console.log(`[handleCloseSalesLogic] Adding batch set for historical general sales: ${generalSaleDocRef.id}, data: ${JSON.stringify({ date: date, vendor: selectedVendor, totalOverallSale: totalOverallSale, itemsSoldSummary: itemsSoldSummary })}`);
                    batch.set(generalSaleDocRef, {
                        date: date,
                        vendor: selectedVendor,
                        totalOverallSale: totalOverallSale,
                        itemsSoldSummary: itemsSoldSummary,
                        rawCSV: combinedCSVContent,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    const uniqueSKUs = new Set();
                    const clientSalesData = {};
                    salesForThisDate.forEach(sale => {
                        if (!clientSalesData[sale.client.id]) {
                            clientSalesData[sale.client.id] = { clientName: sale.client.nombreComercial, total: 0, skus: {} };
                        }
                        sale.items.forEach(item => {
                            uniqueSKUs.add(item.sku);
                            clientSalesData[sale.client.id].skus[item.sku] = (clientSalesData[sale.client.id].skus[item.sku] || 0) + item.cantidadVendida;
                            clientSalesData[sale.client.id].total += item.subtotal;
                        });
                    });

                    const sortedUniqueSKUs = Array.from(uniqueSKUs).sort();
                    let clientCSVContent = `Venta General por Clientes - Fecha: ${date}\nVendedor: ${selectedVendor}\n\nCliente,${sortedUniqueSKUs.map(sku => `SKU(${sku})`).join(',')},Total\n`;
                    let grandTotalClients = 0;
                    const clientSalesDetails = [];

                    for (const clientId in clientSalesData) {
                        const clientData = clientSalesData[clientId];
                        let clientRow = `"${clientData.clientName}"`;
                        sortedUniqueSKUs.forEach(sku => { clientRow += `,${clientData.skus[sku] || 0}`; });
                        clientRow += `,${clientData.total.toFixed(2)}\n`;
                        clientCSVContent += clientRow;
                        grandTotalClients += clientData.total;

                        clientSalesDetails.push({
                            clientId: clientId,
                            clientName: clientData.clientName,
                            total: clientData.total,
                            skusSold: clientData.skus
                        });
                    }
                    clientCSVContent += `Total General:,${','.repeat(sortedUniqueSKUs.length)},${grandTotalClients.toFixed(2)}`;


                    const clientSaleDocRef = db.collection('historicalConsolidatedClientSales').doc();
                    console.log(`[handleCloseSalesLogic] Adding batch set for historical client sales: ${clientSaleDocRef.id}, data: ${JSON.stringify({ date: date, vendor: selectedVendor, grandTotalClients: grandTotalClients, clientSalesDetails: clientSalesDetails })}`);
                    batch.set(clientSaleDocRef, {
                        date: date,
                        vendor: selectedVendor,
                        grandTotalClients: grandTotalClients,
                        clientSalesDetails: clientSalesDetails,
                        rawCSV: clientCSVContent,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }

                for (const truckPlate in truckSalesAggregates) {
                    const truckSpecificSales = truckSalesAggregates[truckPlate];
                    const truckInventoryDocRef = db.collection('truck_inventories').doc(truckPlate);
                    const truckInventoryDoc = await truckInventoryDocRef.get();
                    let currentTruckItems = truckInventoryDoc.exists ? (truckInventoryDoc.data().items || []) : [];

                    console.log(`[handleCloseSalesLogic] Processing sales for truck: ${truckPlate}. Initial inventory:`, JSON.stringify(currentTruckItems));

                    for (const sku in truckSpecificSales) {
                        const quantitySoldFromTruck = truckSpecificSales[sku];
                        const itemIndex = currentTruckItems.findIndex(item => item.sku === sku);
                        if (itemIndex !== -1) {
                            console.log(`[handleCloseSalesLogic] Deducting ${quantitySoldFromTruck} of SKU ${sku} from truck ${truckPlate}. Before: ${currentTruckItems[itemIndex].quantity}`);
                            currentTruckItems[itemIndex].quantity = Math.max(0, currentTruckItems[itemIndex].quantity - quantitySoldFromTruck);
                            console.log(`[handleCloseSalesLogic] After deduction: ${currentTruckItems[itemIndex].quantity}`);
                        } else {
                            messages.push(`Advertencia: SKU ${sku} vendido desde el camión ${truckPlate} no encontrado en su inventario durante el cierre.`);
                            console.warn(`[handleCloseSalesLogic] SKU ${sku} sold from truck ${truckPlate} not found in its inventory during closure.`);
                        }
                    }
                    const filteredTruckItems = currentTruckItems.filter(item => item.quantity > 0);
                    console.log(`[handleCloseSalesLogic] Adding batch set for truck ${truckPlate} inventory: ${JSON.stringify(filteredTruckItems)}`);
                    batch.set(truckInventoryDocRef, { items: filteredTruckItems });
                }

                allProcessedSaleDocIds.forEach(docId => {
                    console.log(`[handleCloseSalesLogic] Adding batch delete for daily sale DOC ID ${docId}.`);
                    batch.delete(db.collection('dailySales').doc(docId));
                });
                dailySales = dailySales.filter(sale => !allProcessedSaleDocIds.includes(sale.docId));
                console.log('[handleCloseSalesLogic] Local daily sales updated. Remaining sales:', dailySales.length);

                await batch.commit();
                console.log('[handleCloseSalesLogic] Firestore batch commit successful.');
                messages.push('Inventario Principal Actualizado: Las ventas han sido deducidas del inventario principal.');
                messages.push('Inventarios de Camiones Actualizados: Los inventarios de los camiones afectados han sido actualizados.');
                messages.push('Archivos Borrados: Los archivos de ventas individuales procesados han sido "borrados" de Firestore.');
            } catch (error) {
                console.error('[handleCloseSalesLogic] Error during Firestore batch commit:', error);
                console.error(`[handleCloseSalesLogic] Firestore Error Code: ${error.code}, Message: ${error.message}`);
                if (error.code === 'unavailable' || error.code === 'internal' || error.code === 'failed-precondition' || error.code === 'permission-denied') {
                    messages.push(`Error de Conexión/Permisos: No se pudo completar el cierre de ventas debido a problemas de red o reglas de seguridad. Por favor, verifica tu conexión y las reglas de seguridad de Firestore. Los datos no se han borrado de la nube.`);
                } else {
                    messages.push('Error al procesar el cierre de ventas. Por favor, revisa tu conexión y las reglas de seguridad.');
                }
            }
            setScreenAndRender('main');
            showMessageModal(messages.join('\n'));
        };

        const generateThermalReceiptHtml = (saleRecord) => {
            let itemsHtml = saleRecord.items.map(item => `
                <div class="item-row">
                    <span class="item-qty">${item.cantidadVendida}x</span>
                    <span class="item-desc">${item.producto} (${item.presentacion})</span>
                    <span class="item-price">$${item.precioUnitario.toFixed(2)}</span>
                    <span class="item-total">$${item.subtotal.toFixed(2)}</span>
                </div>
            `).join('');

            let modificationReasonHtml = saleRecord.modificationReason ? `
                <div style="border-top: 1px dashed #000; margin: 5px 0;"></div>
                <p style="font-weight: bold;">Motivo Modificación:</p>
                <p>${saleRecord.modificationReason}</p>
            ` : '';

            return `
                <div class="thermal-receipt">
                    <h3>Dist Castillo Ventas</h3>
                    <h4>Recibo de Venta</h4>
                    <div class="divider"></div>
                    <p>Fecha: ${saleRecord.date}</p>
                    <p>Cliente: ${saleRecord.client.nombreComercial}</p>
                    <p>Vendedor: ${saleRecord.vendor || selectedVendor}</p>
                    <div class="divider"></div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                        <span class="item-qty">Cant.</span>
                        <span class="item-desc">Producto</span>
                        <span class="item-price">Total</span>
                    </div>
                    <div class="divider"></div>
                    ${itemsHtml}
                    <div class="divider"></div>
                    <div class="total-line">
                        <span>TOTAL:</span>
                        <span>$${saleRecord.total.toFixed(2)}</span>
                    </div>
                    ${modificationReasonHtml}
                    <div class="divider"></div>
                    <p class="footer-text">¡Gracias por tu compra!</p>
                </div>
            `;
        };

        const printSaleReceipt = async (saleRecord) => {
            showMessageModal('Generando imagen del recibo...');
            const receiptHtml = generateThermalReceiptHtml(saleRecord);

            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            tempDiv.style.width = '250px';
            tempDiv.innerHTML = receiptHtml;
            document.body.appendChild(tempDiv);

            try {
                const canvas = await html2canvas(tempDiv, { scale: 2, logging: false, useCORS: true });
                const imageDataUrl = canvas.toDataURL('image/png');

                if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([], 'recibo.png', { type: 'image/png' })] })) {
                    const response = await fetch(imageDataUrl);
                    const blob = await response.blob();
                    const file = new File([blob], `recibo_venta_${saleRecord.client.nombreComercial.replace(/\s/g, '_')}_${saleRecord.date}.png`, { type: 'image/png' });
                    await navigator.share({
                        files: [file],
                        title: `Recibo de Venta ${saleRecord.fileName}`,
                        text: `Aquí tienes el recibo de venta para ${saleRecord.client.nombreComercial} del ${saleRecord.date}. Total: $${saleRecord.total.toFixed(2)}`,
                    });
                    showMessageModal('Recibo compartido exitosamente a través de las opciones de tu dispositivo.');
                } else {
                    showMessageModal('La función de compartir avanzada no está disponible en este navegador. Se descargará la imagen del recibo.');
                    const link = document.createElement('a');
                    link.download = `recibo_venta_${saleRecord.client.nombreComercial.replace(/\s/g, '_')}_${saleRecord.date}.png`;
                    link.href = imageDataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    showMessageModal('La imagen del recibo ha sido descargada.');
                }
            } catch (error) {
                console.error('[printSaleReceipt] Error al generar o compartir la imagen:', error);
                showMessageModal('Error al generar o compartir la imagen del recibo. Intenta de nuevo.');
            } finally {
                if (tempDiv && tempDiv.parentNode) {
                    document.body.removeChild(tempDiv);
                }
            }
        };

        const renderArchivosAdminScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden acceder a esta sección.'); setScreenAndRender('main'); return; }
            appRoot.innerHTML = createScreenContainer('ARCHIVOS ADMIN', `
                <p class="text-base text-center my-5 text-gray-600">Esta sección permite cargar y descargar archivos de datos maestros.</p>
                <div class="mb-8 p-4 bg-sky-50 rounded-lg border border-sky-300">
                    <h3 class="text-xl font-bold mb-4 text-sky-700">Cargar Archivos CSV</h3>
                    <div class="mb-3"><label class="block text-gray-700 text-sm font-bold mb-2">Cargar clientes.csv:</label><div class="file-input-wrapper">${createButton('Seleccionar archivo', 'uploadClientsCsvButton', 'bg-sky-500 w-full')}<input type="file" id="uploadClientsCsv" accept=".csv"></div></div>
                    <div class="mb-3"><label class="block text-gray-700 text-sm font-bold mb-2">Cargar inventario.csv (Almacén Principal):</label><div class="file-input-wrapper">${createButton('Seleccionar archivo', 'uploadInventoryCsvButton', 'bg-sky-500 w-full')}<input type="file" id="uploadInventoryCsv" accept=".csv" data-type="inventory"></div></div>
                    <div class="mb-3"><label class="block text-gray-700 text-sm font-bold mb-2">Cargar vendedor.csv:</label><div class="file-input-wrapper">${createButton('Seleccionar archivo', 'uploadVendorsCsvButton', 'bg-sky-500 w-full')}<input type="file" id="uploadVendorsCsv" accept=".csv" data-type="vendors"></div></div>
                    <div class="mb-3"><label class="block text-gray-700 text-sm font-bold mb-2">Cargar vehículos.csv:</label><div class="file-input-wrapper">${createButton('Seleccionar archivo', 'uploadVehiclesCsvButton', 'bg-sky-500 w-full')}<input type="file" id="uploadVehiclesCsv" accept=".csv" data-type="vehicles"></div></div>
                </div>
                <div class="mb-8 p-4 bg-emerald-50 rounded-lg border border-emerald-300">
                    <h3 class="text-xl font-bold mb-4 text-emerald-700">Descargar Archivos de Datos</h3>
                    ${createButton('Descargar clientes.csv', 'downloadClientsCsvButton', 'bg-emerald-600 w-full mb-2 download-csv-button', { filename: 'clientes.csv' })}
                    ${createButton('Descargar inventario.csv (Almacén Principal)', 'downloadInventoryCsvButton', 'bg-emerald-600 w-full mb-2 download-csv-button', { filename: 'inventario.csv' })}
                    ${createButton('Descargar vendedor.csv', 'downloadVendorsCsvButton', 'bg-emerald-600 w-full mb-2 download-csv-button', { filename: 'vendedor.csv' })}
                    ${createButton('Descargar vehículos.csv', 'downloadVehiclesCsvButton', 'bg-emerald-600 w-full mb-2 download-csv-button', { filename: 'vehiculos.csv' })}
                </div>
                ${createButton('Volver', 'backToMainFromArchivosAdminButton', 'bg-gray-600 mt-5 w-full')}
            `);
        };

        const renderArchivosVentaScreen = () => {
            if (!currentUser) { showMessageModal('Acceso denegado: Debes iniciar sesión para ver los archivos de venta.'); setScreenAndRender('login'); return; }
            const saleFilesHtml = dailySales.length === 0 ? '<p class="text-gray-600">No hay archivos de venta generados.</p>' :
                dailySales.map(sale => `
                    <div class="bg-cyan-100 p-3 rounded-lg mb-2 flex flex-wrap justify-between items-center border border-cyan-200">
                        <span class="text-base text-cyan-800 mb-2 sm:mb-0">${sale.fileName}</span>
                        <div class="flex flex-wrap gap-2">
                            <button class="bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-3 rounded-md text-sm transition duration-150 ease-in-out print-receipt-button" data-sale='${JSON.stringify(sale)}'>IMPRIMIR</button>
                            ${isAdmin() ? `<button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-3 rounded-md text-sm transition duration-150 ease-in-out modify-sale-button" data-sale='${JSON.stringify(sale)}'>MODIFICAR</button>` : ''}
                        </div>
                    </div>
                `).join('');

            appRoot.innerHTML = createScreenContainer('ARCHIVOS DE VENTA', `
                <p class="text-base text-center my-5 text-gray-600">Aquí puedes ver, imprimir y modificar (solo administradores) los archivos de venta generados.</p>
                <div class="p-4 bg-cyan-50 rounded-lg border border-cyan-300">
                    <h3 class="text-xl font-bold mb-4 text-cyan-700">Archivos de Venta Generados</h3>
                    <div id="generated-sale-files-list">${saleFilesHtml}</div>
                </div>
                ${createButton('Volver', 'backToMainFromArchivosVentaButton', 'bg-gray-600 mt-5 w-full')}
            `);
        };

        const openModifySaleModal = (saleRecord) => {
            selectedSaleForModification = JSON.parse(JSON.stringify(saleRecord));
            modifiedSaleQuantities = {};
            selectedSaleForModification.items.forEach(item => { modifiedSaleQuantities[item.sku] = item.cantidadVendida; });
            modificationReason = selectedSaleForModification.modificationReason || '';
            showModifySaleModalState = true;
            render();
        };

        const closeModifySaleModal = () => {
            showModifySaleModalState = false;
            selectedSaleForModification = null;
            modifiedSaleQuantities = {};
            modificationReason = '';
            render();
        };

        const handleModifiedSaleQuantityChange = (sku, quantity) => {
            modifiedSaleQuantities[sku] = parseInt(quantity) || 0;
        };

        const handleModificationReasonChange = (reason) => {
            modificationReason = reason;
        };

        const renderModifySaleModal = () => {
            if (!showModifySaleModalState || !selectedSaleForModification) return '';

            let productsHtml = '';
            let currentSaleSkus = new Set(selectedSaleForModification.items.map(item => item.sku));
            // Use the getter function for currentTruckInventory
            const inventoryToCompare = (selectedSaleForModification.sourceInventory === 'warehouse') ? inventory : inventoryManagement.getCurrentTruckInventory();

            const renderProductRow = (item, isNew = false) => {
                const productInInventory = inventoryToCompare.find(invItem => invItem.sku === item.sku);
                const currentQuantity = modifiedSaleQuantities[item.sku] !== undefined ? modifiedSaleQuantities[item.sku] : (isNew ? 0 : item.cantidadVendida);
                const price = item.precioUnitario !== undefined ? item.precioUnitario : (productInInventory?.price !== undefined ? productInInventory.price : productInInventory?.precio);
                return `
                    <tr>
                        <td><img src="${productImages[item.sku] || productImages['default']}" alt="Imagen de ${item.producto}" class="w-10 h-10 rounded-md object-cover"></td>
                        <td>${item.sku}</td><td>${item.producto}</td><td>${item.presentacion}</td><td>$${price.toFixed(2)}</td>
                        <td><input type="number" class="border border-gray-300 rounded-md text-center w-20 modified-sale-quantity-input" value="${currentQuantity}" data-sku="${item.sku}" min="0"></td>
                        <td>${productInInventory ? (productInInventory.quantity || productInInventory.cantidad) : 'N/A'}</td>
                    </tr>
                `;
            };

            productsHtml += selectedSaleForModification.items.map(item => renderProductRow(item)).join('');
            productsHtml += inventoryToCompare.filter(item => !currentSaleSkus.has(item.sku)).map(item => renderProductRow(item, true)).join('');

            return `
                <div id="modify-sale-modal" class="modal">
                    <div class="modal-content">
                        <h3 class="text-2xl font-bold mb-4 text-center text-indigo-700">Modificar Venta</h3>
                        <p class="text-lg font-bold mb-2">Cliente: ${selectedSaleForModification.client.nombreComercial}</p>
                        <p class="text-md text-gray-700 mb-4">Fecha: ${selectedSaleForModification.date}</p>
                        <p class="text-md text-gray-700 mb-4">Origen: ${selectedSaleForModification.sourceInventory === 'warehouse' ? 'Almacén Principal' : `Camión ${selectedSaleForModification.sourceInventory}`}</p>
                        ${createTable(['Imagen', 'SKU', 'Producto', 'Presentación', 'Precio Unitario', 'Cantidad', 'Disp. Actual'], productsHtml, 'modify-sale-products-body')}
                        <div class="mb-4 text-left">
                            <label for="modificationReason" class="block text-gray-700 text-sm font-bold mb-2">Motivo de la Modificación:</label>
                            <textarea id="modificationReason" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" rows="3">${modificationReason}</textarea>
                        </div>
                        <div class="flex justify-around gap-4 mt-5">
                            ${createButton('Guardar Modificación', 'modifySaleModalSaveButton', 'bg-emerald-600 flex-1')}
                            ${createButton('Cancelar', 'modifySaleModalCancelButton', 'bg-gray-600 flex-1')}
                        </div>
                    </div>
                </div>
            `;
        };

        const saveModifiedSale = async () => {
            if (!modificationReason.trim()) { showMessageModal('Por favor, ingresa un motivo para la modificación.'); return; }

            const oldSaleItemsMap = new Map(selectedSaleForModification.items.map(item => [item.sku, item.cantidadVendida]));
            const newSaleItems = [];
            let newTotalSaleAmount = 0;
            let inventoryUpdates = {};

            const sourceInventoryPlate = selectedSaleForModification.sourceInventory;
            let currentInventoryDataForValidation;

            if (sourceInventoryPlate === 'warehouse') {
                currentInventoryDataForValidation = inventory;
            } else {
                // Use the getter function
                currentInventoryDataForValidation = JSON.parse(JSON.stringify(inventoryManagement.getCurrentTruckInventory()));
            }

            for (const sku in modifiedSaleQuantities) {
                const newQty = modifiedSaleQuantities[sku];
                const oldQty = oldSaleItemsMap.get(sku) || 0;
                const netChange = newQty - oldQty;

                const productInInventory = currentInventoryDataForValidation.find(invItem => invItem.sku === sku);
                const availableQuantity = productInInventory ? (productInInventory.quantity !== undefined ? productInInventory.quantity : productInInventory.cantidad) : 0;

                if (netChange > 0 && netChange > availableQuantity + oldQty) {
                    showMessageModal(`Error: La cantidad adicional de "${sku}" (${netChange}) excede el stock disponible (${availableQuantity}).`);
                    return; // Exit if validation fails
                }

                if (newQty > 0) {
                    const productDetails = inventory.find(item => item.sku === sku) || inventoryManagement.getCurrentTruckInventory().find(item => item.sku === sku); // Use getter here
                    if (productDetails) {
                        const price = productDetails.price !== undefined ? productDetails.price : productDetails.precio;
                        newSaleItems.push({ sku: productDetails.sku, producto: productDetails.producto, presentacion: productDetails.presentacion, cantidadVendida: newQty, precioUnitario: price, subtotal: newQty * price });
                        newTotalSaleAmount += newQty * price;
                    }
                }
                if (netChange !== 0) inventoryUpdates[sku] = (inventoryUpdates[sku] || 0) + netChange;
            }

            if (newSaleItems.length === 0 && Object.keys(inventoryUpdates).length === 0) {
                showMessageModal('La venta modificada no puede estar vacía y no hay cambios de inventario. Ajusta las cantidades o cancela.'); return;
            }

            selectedSaleForModification.items = newSaleItems;
            selectedSaleForModification.total = newTotalSaleAmount;
            selectedSaleForModification.modificationReason = modificationReason.trim();
            selectedSaleForModification.rawCSV =
                `SKU,Producto,Presentacion,Cantidad,Precio Unitario,Subtotal\n` +
                newSaleItems.map(item => `${item.sku},${item.producto},${item.presentacion},${item.cantidadVendida},${item.precioUnitario.toFixed(2)},${item.subtotal.toFixed(2)}`).join('\n') +
                `\nTotal General:, , , , ,${newTotalSaleAmount.toFixed(2)}\n` +
                `Motivo de Modificación:,${modificationReason.trim()}`;

            dailySales = dailySales.map(sale => sale.docId === selectedSaleForModification.docId ? selectedSaleForModification : sale);

            if (sourceInventoryPlate && sourceInventoryPlate !== 'warehouse') {
                // Use the getter function to get current state
                let currentTruckItems = JSON.parse(JSON.stringify(inventoryManagement.getCurrentTruckInventory()));
                for (const sku in inventoryUpdates) {
                    const delta = inventoryUpdates[sku];
                    const itemIndex = currentTruckItems.findIndex(item => item.sku === sku);
                    const productDetails = inventory.find(item => item.sku === sku);

                    if (itemIndex !== -1) {
                        currentTruckItems[itemIndex].quantity = Math.max(0, currentTruckItems[itemIndex].quantity - delta);
                    } else if (delta > 0 && productDetails) {
                        currentTruckItems.push({
                            sku: productDetails.sku, rubro: productDetails.rubro, segmento: productDetails.segmento,
                            producto: productDetails.producto, presentacion: productDetails.presentacion,
                            quantity: delta, price: productDetails.precio
                        });
                    }
                }
                currentTruckItems = currentTruckItems.filter(item => item.quantity > 0);
                // Use the setter function to update
                if (currentUserData.assignedTruckPlate === sourceInventoryPlate) inventoryManagement.setCurrentTruckInventory(currentTruckItems);
            }

            closeModifySaleModal();
            showMessageModal('Venta modificada y guardada localmente. Se sincronizará cuando haya conexión a internet.');

            try {
                const batch = db.batch();
                batch.set(db.collection('dailySales').doc(selectedSaleForModification.docId), selectedSaleForModification);

                if (sourceInventoryPlate && sourceInventoryPlate !== 'warehouse') {
                    batch.set(db.collection('truck_inventories').doc(sourceInventoryPlate), { items: inventoryManagement.getCurrentTruckInventory() }); // Use getter here
                }

                await batch.commit();
                console.log('Firestore commit successful for modified sale:', selectedSaleForModification.fileName);

                await fetchDataFromFirestore();

            } catch (error) {
                console.error('Error al modificar venta en Firestore (puede ser por falta de conexión):', error);
                if (error.code !== 'unavailable' && error.code !== 'internal' && error.code !== 'failed-precondition') {
                    showMessageModal('Error al guardar la modificación de venta en la nube. Por favor, revisa tu conexión y las reglas de seguridad.');
                }
            }
        };

        const handleFileUpload = async (event, type) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const parsedData = parseCSV(e.target.result);
                try {
                    if (type === 'vendors') {
                        const collectionRef = db.collection('vendors');
                        const existingSnapshot = await collectionRef.get();
                        const deleteBatch = db.batch();
                        existingSnapshot.docs.forEach(doc => deleteBatch.delete(doc.ref));
                        await deleteBatch.commit();
                        console.log(`[handleFileUpload] Existing ${type} documents deleted.`);

                        const addBatch = db.batch();
                        for (const row of parsedData) {
                            addBatch.set(collectionRef.doc((row['Wilfredo Chacon'] || row.Name).replace(/\s/g, '_')), { name: row['Wilfredo Chacon'] || row.Name, category: row['Alimentos'] || row.Category });
                        }
                        await addBatch.commit();
                        console.log(`[handleFileUpload] New ${type} documents added.`);
                        showMessageModal(`${type}.csv cargado y guardado exitosamente en Firestore.`);
                        if (vendors.length > 0 && selectedVendor === 'Ninguno') {
                            selectedVendor = vendors.length > 0 ? vendors[0].name : 'Ninguno';
                            localStorage.setItem('selectedVendor', selectedVendor);
                        }
                    } else {
                        // Delegate to inventoryManagement for 'inventory' and 'vehicles'
                        await inventoryManagement.handleFileUpload(event, type);
                    }
                    await fetchDataFromFirestore();
                    render();
                } catch (error) {
                    console.error('Error al cargar archivo CSV a Firestore:', error);
                    showMessageModal('Error al cargar archivo. Por favor, revisa tu conexión y las reglas de seguridad de Firestore.');
                }
            };
            reader.readAsText(file);
        };

        const downloadExistingCSV = (filename) => {
            let csvContent = '';
            const findContent = (arr, key, val) => arr.find(record => record[key] === val);

            const saleRecord = findContent(dailySales, 'fileName', filename);

            if (saleRecord) {
                csvContent = saleRecord.rawCSV;
            } else if (filename === 'clientes.csv') {
                clientManagement.downloadClientsCSV();
                return;
            } else if (filename === 'inventario.csv' || filename === 'vehiculos.csv' || filename.startsWith('carga_') || filename.startsWith('traslado_')) {
                // Delegate to inventoryManagement for inventory and vehicle related CSVs
                inventoryManagement.downloadExistingCSV(filename);
                return;
            } else {
                let dataToDownload = [];
                let headers = [];
                switch (filename) {
                    case 'vendedor.csv':
                        dataToDownload = vendors.map(v => ({ Name: v.name, Category: v.category }));
                        headers = ['Name', 'Category'];
                        break;
                    default:
                        showMessageModal(`No se encontró contenido para descargar el archivo: ${filename}`);
                        return;
                }
                csvContent = toCSV(dataToDownload, headers);
            }
            triggerCSVDownload(filename, csvContent);
        };

        // --- Configuración de Firebase ---
        const firebaseConfig = {
            apiKey: "AIzaSyDLf4iOoqw0yecLPAMUkniHJTMF3YhRY7A",
            authDomain: "dist-castillo.firebaseapp.com",
            projectId: "dist-castillo",
            storageBucket: "dist-castillo.firebasestorage.app",
            messagingSenderId: "249846475959",
            appId: "1:249846475959:web:066c3fbca65ca39655af132",
            measurementId: "G-V56MBM5YT9"
        };

        const app = firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        firebase.firestore().enablePersistence()
            .then(() => console.log("[Firestore] Persistencia offline de Firestore habilitada."))
            .catch((err) => {
                if (err.code == 'failed-precondition') {
                    console.warn("[Firestore] La persistencia offline no se pudo habilitar porque el navegador no la soporta o ya está en uso.", err);
                } else if (err.code == 'unimplemented') {
                    console.warn("[Firestore] El navegador actual no soporta la persistencia offline de Firestore.", err);
                } else {
                    console.error("[Firestore] Error al habilitar la persistencia offline de Firestore:", err);
                }
            });

        // --- Funciones de Carga de Datos desde Firestore ---
        const fetchDataFromFirestore = async () => {
            console.log('[fetchDataFromFirestore] Starting data fetch...');
            try {
                const fetchCollection = async (collectionName, initialData, idKey) => {
                    const snapshot = await db.collection(collectionName).get();
                    if (snapshot.empty) {
                        console.log(`[fetchCollection] Collection '${collectionName}' is empty. Populating with initial data.`);
                        const batch = db.batch();
                        for (const item of initialData) {
                            batch.set(db.collection(collectionName).doc(item[idKey]), item);
                        }
                        await batch.commit();
                        return initialData;
                    } else {
                        console.log(`[fetchCollection] Collection '${collectionName}' has data. Fetching existing data.`);
                        return snapshot.docs.map(doc => ({ [idKey]: doc.id, ...doc.data() }));
                    }
                };

                // Fetch clients, zones, and sectors via clientManagement
                await clientManagement.fetchClientData();

                // Fetch inventory and vehicles via inventoryManagement
                // inventory and vehicles are updated directly within inventoryManagement.fetchInventoryRelatedData
                // but we need to pass the *reference* to the local variables so inventoryManagement can modify them.
                // This is a bit tricky with primitives/arrays, so we'll re-assign after its call.
                await inventoryManagement.fetchInventoryRelatedData();
                inventory = inventoryManagement._inventory; // Re-assign local inventory after fetch
                vehicles = inventoryManagement._vehicles; // Re-assign local vehicles after fetch


                const usersSnapshot = await db.collection('users').get();
                users = usersSnapshot.docs.map(doc => ({ uid: doc.id, ...doc.data() }));
                console.log('[fetchDataFromFirestore] Users fetched:', users.length);

                const vendorsSnapshot = await db.collection('vendors').get();
                vendors = vendorsSnapshot.docs.map(doc => ({ name: doc.id, ...doc.data() }));
                if (vendors.length === 0) {
                    // Initial vendors if the collection is empty
                    const initialVendors = [
                        { name: 'Wilfredo Chacon', category: 'Alimentos' },
                        { name: 'Yonathan Chavez', category: 'Alimentos' },
                        { name: 'Roberto Chacon', category: 'Cerveceria' },
                    ];
                    const batch = db.batch();
                    for (const vendor of initialVendors) {
                        batch.set(db.collection('vendors').doc(vendor.name), vendor);
                    }
                    await batch.commit();
                    vendors = initialVendors;
                }
                console.log('[fetchDataFromFirestore] Vendors fetched:', vendors.length);


                const dailySalesSnapshot = await db.collection('dailySales').get();
                dailySales = dailySalesSnapshot.docs.map(doc => ({ docId: doc.id, ...doc.data() }));
                console.log('[fetchDataFromFirestore] Daily Sales fetched:', dailySales.length);

                if (!vendors.some(v => v.name === selectedVendor)) {
                    selectedVendor = vendors.length > 0 ? vendors[0].name : 'Ninguno';
                    localStorage.setItem('selectedVendor', selectedVendor);
                    console.log('[fetchDataFromFirestore] Adjusted selectedVendor:', selectedVendor);
                }
                console.log('[fetchDataFromFirestore] Data fetch completed successfully.');
            } catch (error) {
                console.error('[Firestore] Error al cargar datos de Firestore:', error);
                showMessageModal('Error al cargar datos. Usando datos de ejemplo. Por favor, revisa tu conexión y las reglas de seguridad de Firestore.');
                // Revert to initial data for non-client related collections
                inventory = []; // Will be populated by inventoryManagement's fallback
                vehicles = []; // Will be populated by inventoryManagement's fallback
                vendors = [{ name: 'Wilfredo Chacon', category: 'Alimentos' }]; // Fallback for vendors
                dailySales = [];
                users = [];
                inventoryManagement.setCurrentTruckInventory([]); // Use setter for fallback
                inventoryManagement.loadRecords = []; // Direct assignment is fine for exported `let`
                inventoryManagement.transferRecords = []; // Direct assignment is fine for exported `let`

                clientManagement.clients = []; // Direct assignment is fine for exported `let`
                clientManagement.zones = []; // Direct assignment is fine for exported `let`
                clientManagement.sectors = []; // Direct assignment is fine for exported `let`
            } finally {
                console.log('[fetchDataFromFirestore] Calling render() from finally block.');
                render();
            }
        };

        // --- Lógica de Autenticación de Firebase ---
        const handleAuth = async (isRegister) => {
            const email = document.getElementById(`${isRegister ? 'register' : 'login'}Email`).value;
            const password = document.getElementById(`${isRegister ? 'register' : 'login'}Password`).value;

            if (!email || !password) {
                showMessageModal('Por favor, ingresa un correo electrónico y una contraseña.');
                return;
            }

            try {
                let userCredential;
                if (isRegister) {
                    userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    await db.collection('users').doc(userCredential.user.uid).set({
                        email: userCredential.user.email,
                        role: 'user',
                        assignedTruckPlate: null,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    showMessageModal(`Registro exitoso para ${userCredential.user.email}! Tu rol es "user". Un administrador deberá asignarte un camión para que puedas realizar ventas.`);
                } else {
                    userCredential = await auth.signInWithEmailAndPassword(email, password);
                }
            } catch (error) {
                showMessageModal(`Error al ${isRegister ? 'registrar' : 'iniciar sesión'}: ${error.message}`);
                console.error(`Error al ${isRegister ? 'registrar' : 'iniciar sesión'}:`, error);
            }
        };

        const handleLogout = async () => {
            try {
                await auth.signOut();
                showMessageModal('Sesión cerrada correctamente.');
                setScreenAndRender('login');
            } catch (error) {
                showMessageModal(`Error al cerrar sesión: ${error.message}`);
                console.error("Error al cerrar sesión:", error);
            }
        };

        auth.onAuthStateChanged(async (user) => {
            console.log('[Auth State Changed] User:', user ? user.email : 'No user');
            if (user) {
                currentUser = user;
                try {
                    const userDoc = await db.collection('users').doc(user.uid).get();
                    currentUserData = userDoc.exists ? userDoc.data() : { email: user.email, role: 'user', assignedTruckPlate: null, createdAt: firebase.firestore.FieldValue.serverTimestamp() };
                    if (!userDoc.exists) {
                        console.log('[Auth State Changed] Creating new user document in Firestore for:', user.email);
                        await db.collection('users').doc(user.uid).set(currentUserData);
                    }
                    console.log('[Auth State Changed] Current User Data:', currentUserData);
                } catch (error) {
                    console.error('[Firestore] Error al cargar el perfil del usuario:', error);
                    showMessageModal('Error al cargar tu perfil. Algunas funciones pueden estar limitadas.');
                    currentUserData = { role: 'user', assignedTruckPlate: null };
                }

                // Initialize modules with necessary data and functions
                clientManagement.init(db, setScreenAndRender);
                inventoryManagement.init(
                    db, currentUserData, isAdmin, isUser, vehicles, inventory, users, vendors, productImages,
                    showMessageModal, showConfirmationModal, createTable, createInput, createSelect, createButton,
                    setScreenAndRender, fetchDataFromFirestore
                );

                console.log('[Auth State Changed] Calling fetchDataFromFirestore...');
                await fetchDataFromFirestore();
                inventoryManagement.setupTruckInventoryListener(); // Setup real-time listener for user's truck inventory

                if (screen === 'login' || screen === 'register') {
                    console.log('[Auth State Changed] Redirecting to main screen.');
                    setScreenAndRender('main');
                } else {
                    console.log('[Auth State Changed] Re-rendering current screen.');
                    render();
                }
            } else {
                currentUser = null;
                currentUserData = { role: 'guest', assignedTruckPlate: null };
                if (inventoryManagement.truckInventoryUnsubscribe) {
                    inventoryManagement.truckInventoryUnsubscribe();
                    inventoryManagement.truckInventoryUnsubscribe = null;
                    console.log('[Firestore Listener] Unsubscribed from user truck inventory listener on logout.');
                }
                if (inventoryManagement.adminTruckInventoryUnsubscribe) {
                    inventoryManagement.adminTruckInventoryUnsubscribe();
                    inventoryManagement.adminTruckInventoryUnsubscribe = null;
                    console.log('[Firestore Listener] Unsubscribed from admin truck inventory listener on logout.');
                }
                // Clear local data
                inventory = [];
                vendors = [];
                dailySales = [];
                vehicles = [];
                users = [];
                inventoryManagement.setCurrentTruckInventory([]); // Use setter for clearing
                inventoryManagement.loadRecords = [];
                inventoryManagement.transferRecords = [];

                clientManagement.closeAllClientModals(); // Clear client-related local data
                clientManagement.clients = [];
                clientManagement.zones = [];
                clientManagement.sectors = [];

                if (screen !== 'login' && screen !== 'register') {
                    console.log('[Auth State Changed] Redirecting to login screen (no user).');
                    setScreenAndRender('login');
                } else {
                    console.log('[Auth State Changed] Staying on login/register screen.');
                    render();
                }
            }
        });

        // --- Event Delegation for the entire app-root ---
        document.addEventListener('DOMContentLoaded', () => {
            const appRoot = document.getElementById('app-root');

            appRoot.addEventListener('click', (event) => {
                const target = event.target;

                // Authentication buttons/links
                if (target.id === 'loginButton') {
                    handleAuth(false);
                } else if (target.id === 'registerLink') {
                    event.preventDefault();
                    setScreenAndRender('register');
                } else if (target.id === 'registerButton') {
                    handleAuth(true);
                } else if (target.id === 'loginLink') {
                    event.preventDefault();
                    setScreenAndRender('login');
                } else if (target.id === 'logoutButton') {
                    handleLogout();
                }
                // Main screen navigation
                else if (target.id === 'cargaSelectionButton') {
                    setScreenAndRender('cargaSelection');
                } else if (target.id === 'adminInventorySelectionButton') {
                    setScreenAndRender('adminInventorySelection');
                } else if (target.id === 'userInventoryButton') {
                    setScreenAndRender('inventario');
                } else if (target.id === 'clientsButton') {
                    setScreenAndRender('clientes');
                } else if (target.id === 'ventaButton') {
                    setScreenAndRender('venta');
                } else if (target.id === 'cierreVentasButton') {
                    showCloseSalesConfirmation();
                } else if (target.id === 'archivosAdminButton') {
                    setScreenAndRender('archivosAdmin');
                } else if (target.id === 'archivosVentaButton') {
                    setScreenAndRender('archivosVenta');
                } else if (target.id === 'vehiclesButton') {
                    setScreenAndRender('vehicles');
                } else if (target.id === 'assignVehicleButton') {
                    setScreenAndRender('assignVehicle');
                } else if (target.id === 'transferInventoryPasswordButton') {
                    setScreenAndRender('transferInventoryPassword');
                } else if (target.id === 'adminTransferHistoryButton') {
                    setScreenAndRender('adminTransferHistory');
                }
                // Modals
                else if (target.id === 'messageModalCloseButton') {
                    hideMessageModal();
                } else if (target.id === 'confirmationModalConfirmButton') {
                    hideConfirmationModal(true);
                } else if (target.id === 'confirmationModalCancelButton') {
                    hideConfirmationModal(false);
                } else if (target.id === 'modifySaleModalSaveButton') {
                    saveModifiedSale();
                } else if (target.id === 'modifySaleModalCancelButton') {
                    closeModifySaleModal();
                }
                // Carga Selection (delegated to inventoryManagement)
                else if (target.id === 'truckLoadingButton') {
                    setScreenAndRender('truckLoading');
                } else if (target.id === 'loadHistoryButton') {
                    setScreenAndRender('loadHistory');
                } else if (target.id === 'resetCargasInicialesPasswordButton') {
                    setScreenAndRender('resetCargasInicialesPassword');
                } else if (target.id === 'backToMainFromCargaSelection') {
                    setScreenAndRender('main');
                }
                // Truck Receiving (delegated to inventoryManagement)
                else if (target.id === 'loadMerchandiseButton') {
                    inventoryManagement.showLoadMerchandiseConfirmation();
                } else if (target.id === 'backToCargaSelectionButton') {
                    setScreenAndRender('cargaSelection');
                }
                // Reset Cargas Iniciales (delegated to inventoryManagement)
                else if (target.id === 'adminPasswordForResetButton') {
                    inventoryManagement.handleResetCargasInicialesPassword();
                } else if (target.id === 'saveResetCargasInicialesButton') {
                    showConfirmationModal('¿Estás seguro de que quieres guardar estos cambios de inventario? Esto sobrescribirá las cantidades actuales.', inventoryManagement.saveResetCargasIniciales);
                } else if (target.id === 'cancelResetCargasInicialesButton' || target.id === 'cancelAndBackToCargaSelectionButton') {
                    setScreenAndRender('cargaSelection');
                }
                // Admin Inventory Selection (delegated to inventoryManagement)
                else if (target.id === 'adminMainInventoryButton') {
                    setScreenAndRender('adminMainInventory');
                } else if (target.id === 'adminVehicleInventoryButton') {
                    setScreenAndRender('adminVehicleInventory');
                } else if (target.id === 'backToMainFromAdminInventorySelection') {
                    setScreenAndRender('main');
                }
                // Admin Main Inventory (delegated to inventoryManagement)
                else if (target.id === 'backToAdminInventorySelectionButton') {
                    setScreenAndRender('adminInventorySelection');
                }
                // Inventario (User) (delegated to inventoryManagement)
                else if (target.id === 'backToMainFromUserInventoryButton') {
                    setScreenAndRender('main');
                }
                // Admin Vehicle Inventory (delegated to inventoryManagement)
                else if (target.id === 'backToAdminInventorySelectionFromVehicleInventoryButton') {
                    setScreenAndRender('adminInventorySelection');
                }
                // Venta
                else if (target.id === 'selectClientButton') {
                    clientManagement.toggleClientPickerModal(true);
                } else if (target.id === 'finalizeSaleButton') {
                    showFinalizeSaleConfirmation();
                } else if (target.id === 'resetVentaStateAndGoToMainButton') {
                    resetVentaStateAndGoToMain();
                }
                // Cierre Ventas
                else if (target.id === 'backToMainFromCierreVentasButton') {
                    setScreenAndRender('main');
                }
                // Archivos Venta
                else if (target.classList.contains('print-receipt-button')) {
                    const saleData = JSON.parse(target.dataset.sale);
                    printSaleReceipt(saleData);
                } else if (target.classList.contains('modify-sale-button')) {
                    const saleData = JSON.parse(target.dataset.sale);
                    openModifySaleModal(saleData);
                } else if (target.id === 'backToMainFromArchivosVentaButton') {
                    setScreenAndRender('main');
                }
                // Archivos Admin
                else if (target.classList.contains('download-csv-button')) {
                    const filename = target.dataset.filename;
                    downloadExistingCSV(filename);
                } else if (target.id === 'backToMainFromArchivosAdminButton') {
                    setScreenAndRender('main');
                }
                // Vehicles (delegated to inventoryManagement)
                else if (target.id === 'addVehicleButton') {
                    inventoryManagement.handleAddVehicle();
                } else if (target.id === 'saveEditedVehicleButton') {
                    inventoryManagement.saveEditedVehicle();
                } else if (target.id === 'cancelEditVehicleButton') {
                    inventoryManagement.cancelEditVehicle();
                } else if (target.classList.contains('edit-vehicle-button')) {
                    const plate = target.dataset.plate;
                    inventoryManagement.editVehicle(plate);
                } else if (target.classList.contains('delete-vehicle-button')) {
                    const plate = target.dataset.plate;
                    inventoryManagement.showDeleteVehicleConfirmation(plate);
                } else if (target.id === 'backToMainFromVehiclesButton') {
                    setScreenAndRender('main');
                }
                // Assign Vehicle (delegated to inventoryManagement)
                else if (target.classList.contains('assign-vehicle-save-button')) {
                    const userId = target.dataset.userid;
                    inventoryManagement.handleAssignVehicle(userId);
                } else if (target.id === 'backToMainFromAssignVehicleButton') {
                    setScreenAndRender('main');
                }
                // Load History (delegated to inventoryManagement)
                else if (target.id === 'clearLoadHistoryButton') {
                    inventoryManagement.showClearLoadHistoryConfirmation();
                } else if (target.id === 'backToCargaSelectionFromLoadHistoryButton') {
                    setScreenAndRender('cargaSelection');
                }
                // Transfer Inventory Password (delegated to inventoryManagement)
                else if (target.id === 'userPasswordForTransferButton') {
                    inventoryManagement.handleTransferInventoryPassword();
                } else if (target.id === 'cancelTransferInventoryPasswordButton') {
                    setScreenAndRender('main');
                }
                // Transfer Inventory (delegated to inventoryManagement)
                else if (target.id === 'performTransferButton') {
                    inventoryManagement.showTransferConfirmation();
                } else if (target.id === 'backToMainFromTransferInventoryButton') {
                    setScreenAndRender('main');
                }
                // Admin Transfer History (delegated to inventoryManagement)
                else if (target.id === 'clearTransferHistoryButton') {
                    inventoryManagement.showClearTransferHistoryConfirmation();
                } else if (target.id === 'backToMainFromAdminTransferHistoryButton') {
                    setScreenAndRender('main');
                }
                // Client Management (main buttons on client screen)
                else if (target.id === 'addClientButton') {
                    clientManagement.openEditClientModal();
                } else if (target.id === 'manageZonesSectorsButton') {
                    clientManagement.openManageZonesSectorsModal();
                } else if (target.classList.contains('edit-client-button')) {
                    const clientId = target.dataset.clientid;
                    const clientToEdit = clientManagement.clients.find(c => c.id === clientId);
                    clientManagement.openEditClientModal(clientToEdit);
                } else if (target.classList.contains('delete-client-button')) {
                    const clientId = target.dataset.clientid;
                    showConfirmationModal(`¿Estás seguro de que quieres eliminar al cliente con ID ${clientId}?`, () => clientManagement.deleteClient(clientId));
                } else if (target.id === 'backToMainFromClientsButton') {
                    setScreenAndRender('main');
                }
                // Client Management (buttons inside modals)
                else if (target.id === 'saveClientButton') {
                    clientManagement.saveClient();
                } else if (target.id === 'cancelEditClientButton') {
                    clientManagement.closeEditClientModal();
                } else if (target.id === 'addZoneButton') {
                    clientManagement.addZone();
                } else if (target.id === 'addSectorButton') {
                    clientManagement.addSector();
                } else if (target.classList.contains('delete-zone-button')) {
                    const zoneName = target.dataset.zonename;
                    showConfirmationModal(`¿Estás seguro de que quieres eliminar la zona "${zoneName}"? Esto no eliminará clientes asociados, pero la zona dejará de estar disponible.`, () => clientManagement.deleteZone(zoneName));
                } else if (target.classList.contains('delete-sector-button')) {
                    const sectorName = target.dataset.sectorname;
                    showConfirmationModal(`¿Estás seguro de que quieres eliminar el sector "${sectorName}"? Esto no eliminará clientes asociados, pero el sector dejará de estar disponible.`, () => clientManagement.deleteSector(sectorName));
                } else if (target.id === 'closeManageZonesSectorsButton') {
                    clientManagement.closeManageZonesSectorsModal();
                } else if (target.id === 'closeClientPickerButton') {
                    clientManagement.toggleClientPickerModal(false);
                } else if (target.classList.contains('select-client-item')) {
                    const clientData = JSON.parse(target.dataset.client);
                    clientManagement.selectClientForSale(clientData);
                }
            });

            appRoot.addEventListener('change', (event) => {
                const target = event.target;

                // File Uploads
                if (target.id === 'uploadClientsCsv') {
                    clientManagement.handleClientFileUpload(event);
                } else if (target.id === 'uploadInventoryCsv' && target.dataset.type === 'inventory') {
                    handleFileUpload(event, 'inventory');
                } else if (target.id === 'uploadVendorsCsv' && target.dataset.type === 'vendors') {
                    handleFileUpload(event, 'vendors');
                } else if (target.id === 'uploadVehiclesCsv' && target.dataset.type === 'vehicles') {
                    handleFileUpload(event, 'vehicles');
                }
                // Truck Receiving (delegated to inventoryManagement)
                else if (target.id === 'loaderSelect') {
                    inventoryManagement.handleLoaderSelection(target.value);
                } else if (target.id === 'truckSelect') {
                    inventoryManagement.handleTruckForReceivingSelection(target.value);
                } else if (target.classList.contains('receiving-quantity-input')) {
                    const sku = target.dataset.sku;
                    inventoryManagement.handleReceivingQuantityChange(sku, target.value);
                }
                // Reset Cargas Iniciales (delegated to inventoryManagement)
                else if (target.classList.contains('reset-quantity-input-main')) {
                    const sku = target.dataset.sku;
                    inventoryManagement.handleResetQuantityChange(sku, 'main', target.value);
                } else if (target.classList.contains('reset-quantity-input-truck')) {
                    const sku = target.dataset.sku;
                    const truckPlate = target.dataset.truckplate;
                    inventoryManagement.handleResetQuantityChange(sku, truckPlate, target.value);
                }
                // Admin Vehicle Inventory (delegated to inventoryManagement)
                else if (target.id === 'adminVehicleSelect') {
                    inventoryManagement.handleAdminVehicleSelection(target.value);
                }
                // Inventario (User) (delegated to inventoryManagement)
                else if (target.id === 'inventorySearchInputUser') {
                    inventoryManagement.filterInventoryForUserScreen(target.value);
                }
                // Venta
                else if (target.classList.contains('sale-quantity-input')) {
                    const sku = target.dataset.sku;
                    handleProductQuantityChange(sku, target.value);
                }
                // Cierre Ventas
                else if (target.name === 'vendor') {
                    handleVendorChange(target.value);
                }
                // Modify Sale Modal
                else if (target.classList.contains('modified-sale-quantity-input')) {
                    const sku = target.dataset.sku;
                    handleModifiedSaleQuantityChange(sku, target.value);
                } else if (target.id === 'modificationReason') {
                    handleModificationReasonChange(target.value);
                }
                // Assign Vehicle (delegated to inventoryManagement)
                else if (target.classList.contains('assign-truck-select')) {
                    const userId = target.dataset.userid;
                    inventoryManagement.handleAssignVehicle(userId);
                }
                // Transfer Inventory (delegated to inventoryManagement)
                else if (target.id === 'destinationTruckSelect') {
                    inventoryManagement.handleDestinationTruckSelection(target.value);
                } else if (target.classList.contains('transfer-quantity-input')) {
                    const sku = target.dataset.sku;
                    inventoryManagement.handleTransferQuantityChange(sku, target.value);
                }
                // Client Management (modal inputs)
                else if (target.id === 'clientPickerSearchInput') {
                    clientManagement.handleClientPickerSearchChange(target.value);
                } else if (target.id === 'clientPickerFilterZone') {
                    clientManagement.handleClientPickerFilterChange('zone', target.value);
                } else if (target.id === 'clientPickerFilterSector') {
                    clientManagement.handleClientPickerFilterChange('sector', target.value);
                }
            });
        });

        if ('serviceWorker' in navigator) {
            document.addEventListener('DOMContentLoaded', () => {
                const serviceWorkerFileName = 'service-worker.js';
                const baseUrl = window.location.pathname.endsWith('/') ? window.location.pathname : window.location.pathname + '/';
                const absoluteServiceWorkerUrl = baseUrl + serviceWorkerFileName;

                navigator.serviceWorker.register(absoluteServiceWorkerUrl)
                    .then(registration => console.log('[Service Worker] Service Worker registrado con éxito:', registration))
                    .catch(error => console.error('[Service Worker] Fallo el registro del Service Worker:', error));
            });
        }

        window.onload = () => {
            console.log('[window.onload] Page fully loaded. Initial render will be triggered by onAuthStateChanged.');
        };
    </script>
</body>
</html>
