<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dist Castillo Ventas</title>
    <!-- Ruta relativa para manifest.json -->
    <link rel="manifest" href="./manifest.json">
    <!-- Carga de Tailwind CSS desde CDN para asegurar que el estilo se aplique correctamente -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
    <!-- html2canvas para convertir HTML a imagen -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            background-image: url('./images/fondo.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed;
            background-color: rgba(0, 0, 0, 0.1);
        }
        #app-root {
            width: 100%;
            max-width: 800px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            padding: 20px;
        }
        .screen-container {
            padding: 0px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: rgba(255, 255, 255, 0.98);
            padding: 35px;
            border-radius: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 600px;
            max-height: 90%;
            overflow-y: auto;
            text-align: center;
        }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
        }
        .table-container {
            overflow-x: auto;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 8px 10px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }
        th {
            background-color: #f8fafc;
            font-weight: 600;
            color: #4a5568;
            text-transform: uppercase;
            font-size: 0.875rem;
            letter-spacing: 0.05em;
        }
        tr:hover {
            background-color: #f0f4f8;
        }
        td input[type="number"] {
            width: 80px;
            padding: 6px 10px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            text-align: center;
        }
        .radio-button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .radio-button-label {
            background-color: #e3f2fd;
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #1976d2;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-weight: 500;
            color: #1976d2;
            text-align: center;
        }
        .radio-button-label:hover {
            background-color: #bbdefb;
        }
        .radio-button-input:checked + .radio-button-label {
            background-color: #1976d2;
            color: white;
            border-color: #0d47a1;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .radio-button-input {
            display: none;
        }
        .thermal-receipt {
            font-family: 'monospace', 'Courier New', Courier, monospace;
            font-size: 0.75rem;
            width: 250px;
            margin: 0 auto;
            padding: 10px;
            border: 1px dashed #ccc;
            background-color: #fff;
            color: #000;
            text-align: left;
            box-shadow: 0 0 5px rgba(0,0,0,0.1);
        }
        .thermal-receipt h3, .thermal-receipt h4 {
            text-align: center;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }
        .thermal-receipt .item-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
        }
        .thermal-receipt .item-qty {
            width: 20%;
            text-align: left;
        }
        .thermal-receipt .item-desc {
            width: 50%;
            text-align: left;
        }
        .thermal-receipt .item-price, .item-total {
            width: 30%;
            text-align: right;
        }
        .thermal-receipt .divider {
            border-top: 1px dashed #000;
            margin: 5px 0;
        }
        .thermal-receipt .total-line {
            display: flex;
            justify-content: space-between;
            font-weight: bold;
            margin-top: 5px;
            font-size: 0.9rem;
        }
        .thermal-receipt .footer-text {
            text-align: center;
            margin-top: 10px;
            font-size: 0.7rem;
        }
        @media print {
            body > *:not(.print-only) {
                display: none !important;
            }
            .print-only {
                display: block !important;
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                height: auto;
                margin: 0;
                padding: 0;
            }
            .thermal-receipt {
                border: none !important;
                box-shadow: none !important;
                width: 100% !important;
                font-size: 10pt;
            }
        }
    </style>
</head>
<body>
    <div id="app-root"></div>

    <script defer>
        console.log('[App Init] Script started.');

        // --- Configuración de Firebase ---
        const firebaseConfig = {
            apiKey: "AIzaSyDLf4iOoqw0yecLPAMUkniHJTMF3YhRY7A",
            authDomain: "dist-castillo.firebaseapp.com",
            projectId: "dist-castillo",
            storageBucket: "dist-castillo.firebasestorage.app",
            messagingSenderId: "249846475959",
            appId: "1:249846475959:web:066c3fbca65ca39655af132",
            measurementId: "G-V56MBM5YT9"
        };

        const app = firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();

        firebase.firestore().enablePersistence()
            .then(() => console.log("[Firestore] Persistencia offline de Firestore habilitada."))
            .catch((err) => {
                if (err.code == 'failed-precondition') {
                    console.warn("[Firestore] La persistencia offline no se pudo habilitar porque el navegador no la soporta o ya está en uso.", err);
                } else if (err.code == 'unimplemented') {
                    console.warn("[Firestore] El navegador actual no soporta la persistencia offline de Firestore.", err);
                } else {
                    console.error("[Firestore] Error al habilitar la persistencia offline de Firestore:", err);
                }
            });

        // --- Datos de la aplicación (se cargarán desde Firestore) ---
        let clients = [];
        let inventory = [];
        let vendors = [];
        let dailySales = [];
        let vehicles = [];
        let currentTruckInventory = []; // This will be updated by the onSnapshot listener for user's assigned truck
        let users = [];
        let loadRecords = [];
        let transferRecords = [];
        let zonesData = [];
        let sectorsData = [];

        // Global variable to hold the unsubscribe function for the user's truck inventory listener
        let truckInventoryUnsubscribe = null;
        // Global variable to hold the unsubscribe function for the admin's selected truck inventory listener
        let adminTruckInventoryUnsubscribe = null;

        // Datos iniciales de ejemplo (se usarán para poblar Firestore si está vacío)
        // (Se mantienen para referencia, pero se asume que Firestore los manejará)
        const initialClients = [
            { id: '1', nombreComercial: 'Los Sartenes de Amita', nombrePersonal: 'Maria Rosario', zona: 'Foranea', sector: 'puerba cambio dos', tlf: '0414555555555', observaciones: 'al frente del chalet' },
            { id: '3', nombreComercial: 'El Parrandereo', nombrePersonal: 'Jose Martinez', zona: 'Santa Teresa', sector: 'Barrio Bolivar', tlf: '787878787878', observaciones: 'ninguna' },
            { id: '4', nombreComercial: 'Licoreria Grysyudey', nombrePersonal: 'Guillermina', zona: 'Palo Gordo', sector: 'Via Principal', tlf: '46898755675', observaciones: 'al doblar la esquina' },
        ];
        const initialInventory = [
            { rubro: 'Cerveceria', sku: '2364', segmento: 'cerveza', producto: 'solera verde', presentacion: '1/4', cantidad: 180, precio: 23 },
            { rubro: 'Cerveceria', sku: '7458', segmento: 'cerveza', producto: 'ligth', presentacion: '1/4', cantidad: 180, precio: 19.8 },
            { rubro: 'Alimentos', sku: '1001', segmento: 'panaderia', producto: 'pan de molde', presentacion: 'unidad', cantidad: 50, precio: 3.5 },
            { rubro: 'Alimentos', sku: '1002', segmento: 'lacteos', producto: 'leche entera', presentacion: 'litro', cantidad: 100, precio: 2.8 },
            { rubro: 'Cerveceria', sku: '9876', segmento: 'cerveza', producto: 'polar pilsen', presentacion: 'tercio', cantidad: 200, precio: 1.5 },
        ];
        const initialVendors = [
            { name: 'Wilfredo Chacon', category: 'Alimentos' },
            { name: 'Yonathan Chavez', category: 'Alimentos' },
            { name: 'Roberto Chacon', category: 'Cerveceria' },
        ];
        const initialVehicles = [
            { plate: 'ABC-123', name: 'Volswaguen Worker 220', brand: 'Volswaguen', model: 'Worker 220' },
            { plate: 'DEF-456', name: 'Chevrolet FVR 300', brand: 'Chevrolet', model: 'FVR 300' },
            { plate: 'GHI-789', name: 'Chevrolet NPR 250', brand: 'Chevrolet', model: 'NPR 250' },
        ];
        const initialZones = [{ name: 'Foranea' }, { name: 'Santa Teresa' }, { name: 'Palo Gordo' }];
        const initialSectors = [{ name: 'puerba cambio dos' }, { name: 'Barrio Bolivar' }, { name: 'Via Principal' }];

        let selectedVendor = localStorage.getItem('selectedVendor') || (initialVendors.length > 0 ? initialVendors[0].name : 'Ninguno');

        const productImages = {
            '2364': './images/2364.png',
            '7458': './images/7458.png',
            '1001': './images/1001.png',
            '1002': './images/1002.png',
            '9876': './images/9876.png',
            'default': './images/no-image.png'
        };

        // --- Funciones de Ayuda ---
        const getCurrentDateFormatted = () => {
            const today = new Date();
            const day = String(today.getDate()).padStart(2, '0');
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const year = today.getFullYear();
            return `${day}${month}${year}`;
        };

        // Nueva función para disparar la descarga de un CSV con contenido dado
        const triggerCSVDownload = (filename, csvContent) => {
            if (!csvContent) {
                showMessageModal(`No se encontró contenido para descargar el archivo: ${filename}`);
                return;
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            } else {
                showMessageModal('La descarga de archivos no es compatible con este navegador.');
            }
        };

        // Función para descargar CSVs existentes (cambiado de downloadCSV a downloadExistingCSV)
        const downloadExistingCSV = (filename) => {
            let csvContent = '';
            const findContent = (arr, key, val) => arr.find(record => record[key] === val);

            const loadRecord = findContent(loadRecords, 'fileName', filename);
            const transferRecord = findContent(transferRecords, 'fileName', filename);
            const saleRecord = findContent(dailySales, 'fileName', filename);

            if (loadRecord) {
                csvContent = loadRecord.rawCSV;
            } else if (transferRecord) {
                csvContent = transferRecord.rawCSV;
            } else if (saleRecord) {
                csvContent = saleRecord.rawCSV;
            } else {
                let dataToDownload = [];
                let headers = [];
                switch (filename) {
                    case 'clientes.csv':
                        dataToDownload = clients.map(c => ({ ID: c.id, 'Nombre Comercial': c.nombreComercial, 'Nombre Personal': c.nombrePersonal, Zona: c.zona, Sector: c.sector, Tlf: c.tlf, Observaciones: c.observaciones }));
                        headers = ['ID', 'Nombre Comercial', 'Nombre Personal', 'Zona', 'Sector', 'Tlf', 'Observaciones'];
                        break;
                    case 'inventario.csv':
                        dataToDownload = inventory.map(i => ({ Rubro: i.rubro, Sku: i.sku, Segmento: i.segmento, Producto: i.producto, Presentacion: i.presentacion, Cantidad: i.cantidad, Precio: i.precio }));
                        headers = ['Rubro', 'Sku', 'Segmento', 'Producto', 'Presentacion', 'Cantidad', 'Precio'];
                        break;
                    case 'vendedor.csv':
                        dataToDownload = vendors.map(v => ({ Name: v.name, Category: v.category }));
                        headers = ['Name', 'Category'];
                        break;
                    case 'vehiculos.csv':
                        dataToDownload = vehicles.map(v => ({ Plate: v.plate, Name: v.name, Brand: v.brand, Model: v.model }));
                        headers = ['Plate', 'Name', 'Brand', 'Model'];
                        break;
                    default:
                        showMessageModal(`No se encontró contenido para descargar el archivo: ${filename}`);
                        return;
                }
                csvContent = toCSV(dataToDownload, headers);
            }
            triggerCSVDownload(filename, csvContent);
        };

        const parseCSV = (csvString) => {
            const lines = csvString.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) return [];
            const headers = lines[0].split(',').map(header => header.trim());
            return lines.slice(1).map(currentLine => {
                const data = currentLine.split(',');
                return headers.reduce((obj, header, j) => {
                    obj[header] = data[j] ? data[j].trim() : '';
                    return obj;
                }, {});
            });
        };

        const toCSV = (data, headers) => {
            if (!data || data.length === 0) return '';
            const actualHeaders = headers || Object.keys(data[0]);
            const csvRows = [actualHeaders.join(',')];
            for (const row of data) {
                const values = actualHeaders.map(header => {
                    const val = row[header];
                    if (typeof val === 'string' && (val.includes(',') || val.includes('"') || val.includes('\n'))) {
                        return `"${val.replace(/"/g, '""')}"`;
                    }
                    return typeof val === 'number' ? val.toString() : val;
                });
                csvRows.push(values.join(','));
            }
            return csvRows.join('\n');
        };

        // --- Estado Global de la Aplicación ---
        let screen = 'login';
        let newClient = { id: '', nombreComercial: '', nombrePersonal: '', zona: '', sector: '', tlf: '', observaciones: '' };
        let selectedClientForSale = null;
        let saleQuantities = {};
        let clientSearchTerm = '';
        let clientSearchTermClientes = '';
        let showClientPickerModal = false;
        let currentProductIndex = 0;
        let showAddClientForm = false;
        let showMessageModalState = false;
        let messageModalText = '';
        let showConfirmationModalState = false;
        let confirmationModalMessage = '';
        let confirmationModalCallback = null;
        let currentUser = null;
        let currentUserData = { role: 'guest', assignedTruckPlate: null };
        const appRoot = document.getElementById('app-root');
        let showModifySaleModalState = false;
        let selectedSaleForModification = null;
        let modifiedSaleQuantities = {};
        let modificationReason = '';
        let editingVehicle = null;
        let selectedTruckForReceiving = null; // Variable de estado para el camión seleccionado en recepción
        let selectedLoader = null; // Variable de estado para el cargador/vendedor seleccionado en recepción
        let receivingQuantities = {}; // Objeto para almacenar las cantidades a recibir por SKU
        let selectedTruckInventoryForReceiving = []; // Inventario del camión seleccionado para la carga
        let selectedAdminVehicleForInventory = null;
        let resetQuantities = {};
        let allTruckInventories = {};
        let selectedDestinationTruck = null;
        let transferQuantities = {};
        let editingClient = null;
        let originalEditingClientId = null;
        let showEditClientModal = false;
        let inventorySearchTermUser = '';
        let showManageZonesSectorsModalState = false;
        let editingZone = null;
        let editingSector = null;

        // --- Funciones de Rol ---
        const isAdmin = () => currentUserData.role === 'admin';
        const isUser = () => currentUserData.role === 'user';

        // --- Funciones de Modales ---
        const showMessageModal = (message) => {
            messageModalText = message;
            showMessageModalState = true;
            render();
        };

        const hideMessageModal = () => {
            showMessageModalState = false;
            messageModalText = '';
            render();
        };

        const renderMessageModal = () => {
            if (!showMessageModalState) return '';
            return `
                <div id="custom-message-modal" class="modal">
                    <div class="modal-content">
                        <p class="text-lg text-center mb-4">${messageModalText}</p>
                        <button class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="hideMessageModal()">Cerrar</button>
                    </div>
                </div>
            `;
        };

        const showConfirmationModal = (message, callback) => {
            confirmationModalMessage = message;
            confirmationModalCallback = callback;
            showConfirmationModalState = true;
            render();
        };

        const hideConfirmationModal = (confirmed) => {
            showConfirmationModalState = false;
            if (confirmed && confirmationModalCallback) {
                confirmationModalCallback();
            }
            confirmationModalCallback = null;
            render();
        };

        const renderConfirmationModal = () => {
            if (!showConfirmationModalState) return '';
            return `
                <div id="confirmation-modal" class="modal">
                    <div class="modal-content">
                        <p class="text-lg text-center mb-6">${confirmationModalMessage}</p>
                        <div class="flex justify-around gap-4">
                            <button class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-5 rounded-lg flex-1 shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="hideConfirmationModal(true)">Confirmar</button>
                            <button class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-5 rounded-lg flex-1 shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="hideConfirmationModal(false)">Cancelar</button>
                        </div>
                    </div>
                </div>
            `;
        };

        // --- Lógica de Autenticación de Firebase ---
        const handleAuth = async (isRegister) => {
            const email = document.getElementById(`${isRegister ? 'register' : 'login'}Email`).value;
            const password = document.getElementById(`${isRegister ? 'register' : 'login'}Password`).value;

            if (!email || !password) {
                showMessageModal('Por favor, ingresa un correo electrónico y una contraseña.');
                return;
            }

            try {
                let userCredential;
                if (isRegister) {
                    userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    await db.collection('users').doc(userCredential.user.uid).set({
                        email: userCredential.user.email,
                        role: 'user',
                        assignedTruckPlate: null,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    showMessageModal(`Registro exitoso para ${userCredential.user.email}! Tu rol es "user". Un administrador deberá asignarte un camión para que puedas realizar ventas.`);
                } else {
                    userCredential = await auth.signInWithEmailAndPassword(email, password);
                }
                // onAuthStateChanged se encargará de cargar los datos del usuario y redirigir
            } catch (error) {
                showMessageModal(`Error al ${isRegister ? 'registrar' : 'iniciar sesión'}: ${error.message}`);
                console.error(`Error al ${isRegister ? 'registrar' : 'iniciar sesión'}:`, error);
            }
        };

        const handleLogout = async () => {
            try {
                await auth.signOut();
                showMessageModal('Sesión cerrada correctamente.');
                setScreenAndRender('login');
            } catch (error) {
                showMessageModal(`Error al cerrar sesión: ${error.message}`);
                console.error("Error al cerrar sesión:", error);
            }
        };

        auth.onAuthStateChanged(async (user) => {
            console.log('[Auth State Changed] User:', user ? user.email : 'No user');
            if (user) {
                currentUser = user;
                try {
                    const userDoc = await db.collection('users').doc(user.uid).get();
                    currentUserData = userDoc.exists ? userDoc.data() : { email: user.email, role: 'user', assignedTruckPlate: null, createdAt: firebase.firestore.FieldValue.serverTimestamp() };
                    if (!userDoc.exists) {
                        console.log('[Auth State Changed] Creating new user document in Firestore for:', user.email);
                        await db.collection('users').doc(user.uid).set(currentUserData);
                    }
                    console.log('[Auth State Changed] Current User Data:', currentUserData);
                } catch (error) {
                    console.error('[Firestore] Error al cargar el perfil del usuario:', error);
                    showMessageModal('Error al cargar tu perfil. Algunas funciones pueden estar limitadas.');
                    currentUserData = { role: 'user', assignedTruckPlate: null };
                }
                console.log('[Auth State Changed] Calling fetchDataFromFirestore...');
                await fetchDataFromFirestore(); // Fetch other data
                setupTruckInventoryListener(); // Setup real-time listener for user's truck inventory

                if (screen === 'login' || screen === 'register') {
                    console.log('[Auth State Changed] Redirecting to main screen.');
                    setScreenAndRender('main');
                } else {
                    console.log('[Auth State Changed] Re-rendering current screen.');
                    render();
                }
            } else {
                currentUser = null;
                currentUserData = { role: 'guest', assignedTruckPlate: null };
                // Unsubscribe when user logs out
                if (truckInventoryUnsubscribe) {
                    truckInventoryUnsubscribe();
                    truckInventoryUnsubscribe = null;
                    console.log('[Firestore Listener] Unsubscribed from user truck inventory listener on logout.');
                }
                if (adminTruckInventoryUnsubscribe) { // Also unsubscribe admin listener on general logout
                    adminTruckInventoryUnsubscribe();
                    adminTruckInventoryUnsubscribe = null;
                    console.log('[Firestore Listener] Unsubscribed from admin truck inventory listener on logout.');
                }
                [clients, inventory, vendors, dailySales, vehicles, currentTruckInventory, users, loadRecords, transferRecords, zonesData, sectorsData] = [[], [], [], [], [], [], [], [], [], [], []];
                if (screen !== 'login' && screen !== 'register') {
                    console.log('[Auth State Changed] Redirecting to login screen (no user).');
                    setScreenAndRender('login');
                } else {
                    console.log('[Auth State Changed] Staying on login/register screen.');
                    render();
                }
            }
        });

        // --- Funciones de Carga de Datos desde Firestore ---
        const fetchDataFromFirestore = async () => {
            console.log('[fetchDataFromFirestore] Starting data fetch...');
            try {
                const fetchCollection = async (collectionName, initialData, idKey, defaultDocData = {}) => {
                    const snapshot = await db.collection(collectionName).get();
                    if (snapshot.empty) {
                        console.log(`[fetchCollection] Collection '${collectionName}' is empty. Populating with initial data.`);
                        for (const item of initialData) {
                            await db.collection(collectionName).doc(item[idKey]).set(item);
                            if (collectionName === 'vehicles') {
                                // Ensure truck_inventories are initialized only once per vehicle
                                const truckInvDoc = await db.collection('truck_inventories').doc(item.plate).get();
                                if (!truckInvDoc.exists) {
                                    await db.collection('truck_inventories').doc(item.plate).set({ items: [] });
                                }
                            }
                        }
                        return initialData;
                    } else {
                        console.log(`[fetchCollection] Collection '${collectionName}' has data. Fetching existing data.`);
                        return snapshot.docs.map(doc => ({ [idKey]: doc.id, ...doc.data() }));
                    }
                };

                clients = await fetchCollection('clients', initialClients, 'id');
                inventory = await fetchCollection('inventory', initialInventory, 'sku');
                vendors = await fetchCollection('vendors', initialVendors, 'name', { name: '', category: '' });
                vehicles = await fetchCollection('vehicles', initialVehicles, 'plate');

                const usersSnapshot = await db.collection('users').get();
                users = usersSnapshot.docs.map(doc => ({ uid: doc.id, ...doc.data() }));
                console.log('[fetchDataFromFirestore] Users fetched:', users.length);

                zonesData = await fetchCollection('zones', initialZones, 'name');
                sectorsData = await fetchCollection('sectors', initialSectors, 'name');

                // currentTruckInventory is now managed by the onSnapshot listener, not fetched here.

                const dailySalesSnapshot = await db.collection('dailySales').get();
                dailySales = dailySalesSnapshot.docs.map(doc => ({ docId: doc.id, ...doc.data() }));
                console.log('[fetchDataFromFirestore] Daily Sales fetched:', dailySales.length);

                if (isAdmin()) {
                    console.log('[fetchDataFromFirestore] User is admin, fetching all load records.');
                    const loadRecordsSnapshot = await db.collection('loadRecords').get();
                    loadRecords = loadRecordsSnapshot.docs.map(doc => ({ docId: doc.id, ...doc.data() }));
                } else {
                    loadRecords = [];
                    console.log('[fetchDataFromFirestore] User is not admin, not fetching all load records.');
                }

                if (isAdmin()) {
                    console.log('[fetchDataFromFirestore] User is admin, fetching all transfer records.');
                    const transferRecordsSnapshot = await db.collection('transferRecords').get();
                    transferRecords = transferRecordsSnapshot.docs.map(doc => ({ docId: doc.id, ...doc.data() }));
                } else if (isUser() && currentUser) {
                    console.log(`[fetchDataFromFirestore] User is regular, fetching transfer records for user: ${currentUser.uid}`);
                    const userTransferRecordsSnapshot = await db.collection('transferRecords').where('userId', '==', currentUser.uid).get();
                    transferRecords = userTransferRecordsSnapshot.docs.map(doc => ({ docId: doc.id, ...doc.data() }));
                } else {
                    transferRecords = [];
                    console.log('[fetchDataFromFirestore] Not fetching transfer records (guest or no user).');
                }

                if (!vendors.some(v => v.name === selectedVendor)) {
                    selectedVendor = vendors.length > 0 ? vendors[0].name : 'Ninguno';
                    localStorage.setItem('selectedVendor', selectedVendor);
                    console.log('[fetchDataFromFirestore] Adjusted selectedVendor:', selectedVendor);
                }
                console.log('[fetchDataFromFirestore] Data fetch completed successfully.');
            } catch (error) {
                console.error('[Firestore] Error al cargar datos de Firestore:', error);
                showMessageModal('Error al cargar datos. Usando datos de ejemplo. Por favor, revisa tu conexión y las reglas de seguridad de Firestore.');
                [clients, inventory, vendors, vehicles, dailySales, currentTruckInventory, users, loadRecords, transferRecords, zonesData, sectorsData] = [initialClients, initialInventory, initialVendors, initialVehicles, [], [], [], [], [], initialZones, initialSectors];
            } finally {
                console.log('[fetchDataFromFirestore] Calling render() from finally block.');
                render(); // Initial render after main data fetch
            }
        };

        const setupTruckInventoryListener = () => {
            // Unsubscribe from any existing user listener
            if (truckInventoryUnsubscribe) {
                truckInventoryUnsubscribe();
                truckInventoryUnsubscribe = null;
                console.log('[Firestore Listener] Unsubscribed from previous user truck inventory listener.');
            }

            if (currentUserData.assignedTruckPlate) {
                const truckInventoryDocRef = db.collection('truck_inventories').doc(currentUserData.assignedTruckPlate);
                console.log(`[Firestore Listener] Setting up onSnapshot for user truck inventory: ${currentUserData.assignedTruckPlate}`);

                truckInventoryUnsubscribe = truckInventoryDocRef.onSnapshot(docSnapshot => {
                    if (docSnapshot.exists) {
                        currentTruckInventory = docSnapshot.data().items || [];
                        console.log(`[Firestore Listener] User truck inventory updated via snapshot for ${currentUserData.assignedTruckPlate}:`, currentTruckInventory.length, 'items.');
                    } else {
                        currentTruckInventory = [];
                        console.log(`[Firestore Listener] User truck inventory document for ${currentUserData.assignedTruckPlate} does not exist or is empty.`);
                    }
                    // Re-render only if on a screen that displays truck inventory, or if it's the main screen
                    if (screen === 'inventario' || screen === 'venta' || screen === 'transferInventory' || screen === 'main') {
                        render();
                    }
                }, error => {
                    console.error('[Firestore Listener] Error listening to user truck inventory:', error);
                    showMessageModal('Error en la sincronización del inventario del camión. Puede que los datos no estén actualizados.');
                });
            } else {
                currentTruckInventory = [];
                console.log('[Firestore Listener] No truck assigned for current user, no listener set up.');
            }
        };

        const setupAdminTruckInventoryListener = (plate) => {
            // Unsubscribe from any existing admin listener
            if (adminTruckInventoryUnsubscribe) {
                adminTruckInventoryUnsubscribe();
                adminTruckInventoryUnsubscribe = null;
                console.log('[Firestore Listener] Unsubscribed from previous admin truck inventory listener.');
            }

            if (plate) {
                const truckInventoryDocRef = db.collection('truck_inventories').doc(plate);
                console.log(`[Firestore Listener] Setting up onSnapshot for admin selected truck inventory: ${plate}`);

                adminTruckInventoryUnsubscribe = truckInventoryDocRef.onSnapshot(docSnapshot => {
                    const displayDiv = document.getElementById('selected-vehicle-inventory-display');
                    if (!displayDiv) {
                        console.warn('[Firestore Listener] Display div for admin truck inventory not found.');
                        return;
                    }

                    if (docSnapshot.exists) {
                        const displayInventory = docSnapshot.data().items || [];
                        console.log(`[Firestore Listener] Admin selected truck inventory updated via snapshot for ${plate}:`, displayInventory.length, 'items.');
                        if (displayInventory.length === 0) {
                            displayDiv.innerHTML = `<p class="text-center text-gray-600 text-lg py-4">Inventario del camión ${plate} vacío por el momento.</p>`;
                        } else {
                            const tableRows = displayInventory.map(item => `
                                <td>${item.rubro}</td><td>${item.sku}</td><td>${item.producto}</td>
                                <td>${item.presentacion}</td><td>${item.quantity}</td><td>$${item.price.toFixed(2)}</td>
                            `).map(row => `<tr>${row}</tr>`).join('');
                            displayDiv.innerHTML = createTable(['Rubro', 'Sku', 'Producto', 'Presentación', 'Cantidad', 'Precio'], tableRows, 'admin-truck-inventory-display-body');
                        }
                    } else {
                        displayDiv.innerHTML = `<p class="text-center text-gray-600 text-lg py-4">Inventario del camión ${plate} no existe o está vacío.</p>`;
                        console.log(`[Firestore Listener] Admin selected truck inventory document for ${plate} does not exist or is empty.`);
                    }
                }, error => {
                    console.error('[Firestore Listener] Error listening to admin selected truck inventory:', error);
                    showMessageModal('Error en la sincronización del inventario del camión para el administrador. Puede que los datos no estén actualizados.');
                    const displayDiv = document.getElementById('selected-vehicle-inventory-display');
                    if (displayDiv) {
                        displayDiv.innerHTML = `<p class="text-center text-red-600 text-lg py-4">Error al cargar el inventario del camión.</p>`;
                    }
                });
            } else {
                console.log('[Firestore Listener] No truck selected for admin, no listener set up.');
            }
        };


        // --- Función Principal de Renderizado ---
        const render = () => {
            console.log(`[Render] Current screen to render: ${screen}`);
            appRoot.innerHTML = '';
            const screenFunctions = {
                'main': renderMainScreen,
                'cargaSelection': renderCargaSelectionScreen,
                'truckLoading': renderTruckReceivingScreen,
                'loadHistory': renderLoadHistoryScreen,
                'inventario': renderInventarioScreen,
                'clientes': renderClientesScreen,
                'venta': renderVentaScreen,
                'cierreVentas': renderCierreVentasScreen,
                'archivosAdmin': renderArchivosAdminScreen,
                'archivosVenta': renderArchivosVentaScreen,
                'vehicles': renderVehiclesScreen,
                'adminInventorySelection': renderAdminInventorySelection,
                'adminMainInventory': renderAdminMainInventoryScreen,
                'adminVehicleInventory': renderAdminVehicleInventoryScreen,
                'assignVehicle': renderAssignVehicleScreen,
                'login': renderLoginScreen,
                'register': renderRegisterScreen,
                'resetCargasInicialesPassword': renderResetCargasInicialesPasswordScreen,
                'resetCargasInicialesEdit': renderResetCargasInicialesEditScreen,
                'transferInventoryPassword': renderTransferInventoryPasswordScreen,
                'transferInventory': renderTransferInventoryScreen,
                'adminTransferHistory': renderAdminTransferHistoryScreen,
            };

            if (!currentUser && screen !== 'login' && screen !== 'register') {
                console.log('[Render] No current user, forcing login screen.');
                renderLoginScreen();
            } else {
                (screenFunctions[screen] || renderMainScreen)();
            }

            appRoot.innerHTML += renderMessageModal();
            appRoot.innerHTML += renderConfirmationModal();
            if (showModifySaleModalState) appRoot.innerHTML += renderModifySaleModal();
            if (showEditClientModal) appRoot.innerHTML += renderEditClientModal();
            if (showManageZonesSectorsModalState) appRoot.innerHTML += renderManageZonesSectorsModal();
            // NEW: Add client picker modal to the main render function
            if (showClientPickerModal) appRoot.innerHTML += renderClientPickerModal();
            console.log('[Render] Render cycle completed.');
        };

        // --- Componentes Reutilizables de UI ---
        const createScreenContainer = (title, content, className = '') => `
            <div class="screen-container bg-white rounded-xl m-2 shadow-md ${className}">
                <h2 class="text-2xl font-bold mb-5 text-center text-indigo-700">${title}</h2>
                ${content}
            </div>
        `;

        const createButton = (text, onClick, className = '') => `
            <button class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 px-6 rounded-lg m-2 min-w-[150px] shadow-md transition duration-300 ease-in-out transform hover:scale-105 border border-indigo-700 ${className}" onclick="${onClick}">${text}</button>
        `;

        const createInput = (id, placeholder, value = '', type = 'text', disabled = false, onChange = '') => `
            <input type="${type}" id="${id}" class="h-12 border border-gray-300 rounded-lg px-4 mb-4 text-base w-full bg-white focus:ring-2 focus:ring-indigo-500 focus:border-transparent" placeholder="${placeholder}" value="${value}" ${disabled ? 'disabled' : ''} onchange="${onChange}">
        `;

        const createSelect = (id, options, selectedValue, onChange = '', placeholder = '-- Seleccione --') => `
            <select id="${id}" class="h-12 border border-gray-300 rounded-lg px-4 text-base w-full bg-white focus:ring-2 focus:ring-blue-500 focus:border-transparent" onchange="${onChange}">
                <option value="">${placeholder}</option>
                ${options.map(opt => `<option value="${opt.value}" ${selectedValue === opt.value ? 'selected' : ''}>${opt.text}</option>`).join('')}
            </select>
        `;

        const createTable = (headers, rowsHtml, id = '') => `
            <div class="table-container mb-5">
                <table>
                    <thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>
                    <tbody id="${id}">${rowsHtml}</tbody>
                </table>
            </div>
        `;

        // --- Pantallas ---
        const renderLoginScreen = () => {
            console.log('[renderLoginScreen] Rendering login screen.');
            appRoot.innerHTML = createScreenContainer('Iniciar Sesión', `
                ${createInput('loginEmail', 'Correo Electrónico', '', 'email')}
                ${createInput('loginPassword', 'Contraseña', '', 'password')}
                <button class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-5 rounded-lg w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="handleAuth(false)">Iniciar Sesión</button>
                <p class="text-center mt-6 text-gray-700">¿No tienes cuenta? <a href="#" class="text-indigo-600 hover:underline font-semibold" onclick="setScreenAndRender('register')">Regístrate aquí</a></p>
            `, 'max-w-md mx-auto my-10');
        };

        const renderRegisterScreen = () => {
            console.log('[renderRegisterScreen] Rendering register screen.');
            appRoot.innerHTML = createScreenContainer('Registrar Nuevo Usuario', `
                ${createInput('registerEmail', 'Correo Electrónico', '', 'email')}
                ${createInput('registerPassword', 'Contraseña', '', 'password')}
                <button class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-5 rounded-lg w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="handleAuth(true)">Registrar</button>
                <p class="text-center mt-6 text-gray-700">¿Ya tienes cuenta? <a href="#" class="text-indigo-600 hover:underline font-semibold" onclick="setScreenAndRender('login')">Inicia sesión aquí</a></p>
            `, 'max-w-md mx-auto my-10');
        };

        const renderMainScreen = () => {
            console.log('[renderMainScreen] Rendering main screen.');
            const buttons = [
                isAdmin() && createButton('CARGA', "setScreenAndRender('cargaSelection')"),
                isAdmin() && createButton('INVENTARIO', "setScreenAndRender('adminInventorySelection')"),
                isUser() && createButton('INVENTARIO', "setScreenAndRender('inventario')"),
                createButton('CLIENTES', "setScreenAndRender('clientes')"),
                isUser() && createButton('VENTA', "setScreenAndRender('venta')"),
                isUser() && createButton('CIERRE VENTAS', "setScreenAndRender('cierreVentas')"), // Accessible by user
                isAdmin() && createButton('ARCHIVOS ADMIN', "setScreenAndRender('archivosAdmin')"),
                !isAdmin() && currentUser && createButton('ARCHIVOS DE VENTA', "setScreenAndRender('archivosVenta')"),
                isAdmin() && createButton('VEHÍCULOS DE CARGA', "setScreenAndRender('vehicles')"),
                isAdmin() && createButton('ASIGNAR VEHÍCULO', "setScreenAndRender('assignVehicle')"),
                isUser() && createButton('TRANSBORDO INV.', "setScreenAndRender('transferInventoryPassword')"),
                isAdmin() && createButton('HISTORIAL TRANSBORDOS', "setScreenAndRender('adminTransferHistory')"),
            ].filter(Boolean).join(''); // Filter out false values and join

            appRoot.innerHTML = `
                <div class="flex flex-col items-center justify-center p-5 bg-blue-50 rounded-xl m-2 shadow-lg">
                    <h1 class="text-3xl font-bold mb-4 text-indigo-700 drop-shadow-sm">Dist Castillo Ventas</h1>
                    ${currentUser ? `<p class="text-md text-gray-700 mb-4">Bienvenido, ${currentUser.email} (${currentUserData.role}) ${currentUserData.assignedTruckPlate ? ` - Camión: ${currentUserData.assignedTruckPlate}` : ''}</p>` : ''}
                    <div class="flex flex-wrap justify-center">${buttons}</div>
                    <button class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg mt-8 shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="handleLogout()">Cerrar Sesión</button>
                </div>
            `;
        };

        const updateVendorSelectionDisplay = () => {
            const vendorRadioGroup = document.getElementById('vendor-radio-group');
            if (!vendorRadioGroup) return;
            vendorRadioGroup.innerHTML = vendors.map(vendor => `
                <input type="radio" id="vendor-${vendor.name.replace(/\s/g, '-')}" name="vendor" value="${vendor.name}" class="radio-button-input" ${selectedVendor === vendor.name ? 'checked' : ''} onchange="handleVendorChange(this.value)">
                <label for="vendor-${vendor.name.replace(/\s/g, '-')}" class="radio-button-label">${vendor.name}</label>
            `).join('');
        };

        const handleVendorChange = (vendorName) => {
            selectedVendor = vendorName;
            localStorage.setItem('selectedVendor', selectedVendor);
        };

        const renderCargaSelectionScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden acceder a la sección de Carga.'); setScreenAndRender('main'); return; }
            appRoot.innerHTML = createScreenContainer('SECCIÓN DE CARGA', `
                <p class="text-base text-center my-5 text-gray-600">Selecciona una opción para la gestión de cargas.</p>
                <div class="flex flex-wrap justify-center gap-4">
                    ${createButton('RECEPCIÓN DE MERCANCÍA EN CAMIÓN', "setScreenAndRender('truckLoading')", 'bg-indigo-600')}
                    ${createButton('HISTORIAL DE CARGAS', "setScreenAndRender('loadHistory')", 'bg-indigo-600')}
                    ${createButton('RESET CARGAS INICIALES', "setScreenAndRender('resetCargasInicialesPassword')", 'bg-red-600 border-red-700')}
                </div>
                ${createButton('Volver', "setScreenAndRender('main')", 'bg-gray-600 mt-5 w-full')}
            `);
        };

        const renderTruckReceivingScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden acceder a esta función.'); setScreenAndRender('main'); return; }

            // Opciones para el selector de cargadores (vendedores)
            const loaderOptions = vendors.map(v => ({ value: v.name, text: v.name }));
            // Opciones para el selector de camiones
            const vehicleOptions = vehicles.map(v => ({ value: v.plate, text: `${v.name} (${v.plate})` }));

            appRoot.innerHTML = createScreenContainer('RECEPCIÓN DE MERCANCÍA EN CAMIÓN', `
                <p class="text-lg text-center mb-6 text-gray-700">Selecciona un cargador y un camión, luego ingresa las cantidades a cargar.</p>

                <div class="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-300">
                    <label for="loaderSelect" class="block text-lg font-semibold text-blue-700 mb-2">Seleccionar Cargador:</label>
                    ${createSelect('loaderSelect', loaderOptions, selectedLoader, 'handleLoaderSelection(this.value)')}
                </div>

                <div class="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-300">
                    <label for="truckSelect" class="block text-lg font-semibold text-blue-700 mb-2">Seleccionar Camión de Destino:</label>
                    ${createSelect('truckSelect', vehicleOptions, selectedTruckForReceiving?.plate, 'handleTruckForReceivingSelection(this.value)')}
                </div>

                <div id="receiving-products-container">
                    <p class="text-center text-gray-600 text-lg py-4">Seleccione un cargador y un camión para empezar a cargar mercancía.</p>
                </div>

                ${createButton('Volver a Carga', "setScreenAndRender('cargaSelection')", 'bg-gray-600 mt-5 w-full')}
            `, 'max-w-md mx-auto my-10');

            // Actualizar el contenido de la tabla de productos si ya hay un camión y cargador seleccionados
            if (selectedLoader && selectedTruckForReceiving) {
                updateTruckReceivingScreenContent();
            }
        };

        const handleLoaderSelection = (loaderName) => {
            selectedLoader = loaderName;
            // Si ya hay un camión seleccionado, actualiza el contenido
            if (selectedTruckForReceiving) {
                updateTruckReceivingScreenContent();
            }
        };

        const handleTruckForReceivingSelection = async (truckPlate) => {
            selectedTruckForReceiving = truckPlate ? vehicles.find(v => v.plate === truckPlate) : null;
            receivingQuantities = {}; // Reset quantities when truck changes

            if (selectedTruckForReceiving) {
                // Fetch the current inventory of the selected truck
                try {
                    const truckInvDoc = await db.collection('truck_inventories').doc(selectedTruckForReceiving.plate).get();
                    selectedTruckInventoryForReceiving = truckInvDoc.exists ? (truckInvDoc.data().items || []) : [];
                    console.log(`[handleTruckForReceivingSelection] Inventario actual del camión ${selectedTruckForReceiving.plate}:`, selectedTruckInventoryForReceiving);
                } catch (error) {
                    console.error('Error al cargar el inventario del camión seleccionado:', error);
                    showMessageModal('Error al cargar el inventario del camión. Intenta de nuevo.');
                    selectedTruckInventoryForReceiving = [];
                }
            } else {
                selectedTruckInventoryForReceiving = [];
            }
            updateTruckReceivingScreenContent();
        };

        const updateTruckReceivingScreenContent = () => {
            const receivingProductsContainer = document.getElementById('receiving-products-container');
            if (!receivingProductsContainer) return;

            if (!selectedLoader || !selectedTruckForReceiving) {
                receivingProductsContainer.innerHTML = `<p class="text-center text-gray-600 text-lg py-4">Seleccione un cargador y un camión para empezar a cargar mercancía.</p>`;
                return;
            }

            // Crear una copia del inventario principal para mostrar y permitir la entrada de cantidades
            const inventoryToDisplay = JSON.parse(JSON.stringify(inventory));

            const tableRows = inventoryToDisplay.map(item => {
                // Obtener la cantidad actual en el inventario principal
                const currentMainQty = item.cantidad;
                // Obtener la cantidad que se ha ingresado para recibir (si existe)
                const qtyToReceive = receivingQuantities[item.sku] || 0;

                return `
                    <tr>
                        <td><img src="${productImages[item.sku] || productImages['default']}" alt="Imagen de ${item.producto}" class="w-10 h-10 rounded-md object-cover"></td>
                        <td>${item.sku}</td>
                        <td>${item.producto}</td>
                        <td>${item.presentacion}</td>
                        <td>${currentMainQty}</td>
                        <td><input type="number" class="border border-gray-300 rounded-md text-center w-20" value="${qtyToReceive}" onchange="handleReceivingQuantityChange('${item.sku}', this.value)" min="0" max="${currentMainQty}"></td>
                    </tr>
                `;
            }).join('');

            receivingProductsContainer.innerHTML = `
                <h3 class="text-xl font-bold mb-4 text-emerald-700">Productos a Cargar</h3>
                ${createTable(['Imagen', 'SKU', 'Producto', 'Presentación', 'Disponible (Principal)', 'Cantidad a Cargar'], tableRows, 'products-for-receiving-body')}
                <button class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-5 rounded-lg mt-5 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="showLoadMerchandiseConfirmation()">Cargar Mercancía</button>
            `;
        };

        const handleReceivingQuantityChange = (sku, quantity) => {
            receivingQuantities[sku] = parseInt(quantity) || 0;
            // No re-render here to avoid losing focus on input. Will re-render on action.
        };

        const showLoadMerchandiseConfirmation = () => {
            showConfirmationModal('¿Estás seguro de que quieres realizar esta carga de mercancía? Esto actualizará los inventarios y registrará la carga.', performLoadMerchandise);
        };

        const performLoadMerchandise = async () => {
            if (!selectedLoader || !selectedTruckForReceiving) {
                showMessageModal('Error: Por favor, selecciona un cargador y un camión antes de cargar mercancía.');
                return;
            }

            const loadData = [];
            let totalLoadAmount = 0;
            let validationErrors = [];
            let hasPositiveLoadQuantity = false;

            // Copias de los inventarios para modificaciones
            let updatedMainInventory = JSON.parse(JSON.stringify(inventory));
            let updatedTruckInventory = JSON.parse(JSON.stringify(selectedTruckInventoryForReceiving));

            for (const sku in receivingQuantities) {
                const quantityToLoad = receivingQuantities[sku];
                if (quantityToLoad <= 0) continue; // Skip items with 0 or negative quantities

                hasPositiveLoadQuantity = true;

                const mainInventoryItem = updatedMainInventory.find(item => item.sku === sku);
                if (!mainInventoryItem) {
                    validationErrors.push(`Error: SKU "${sku}" no encontrado en el inventario principal.`);
                    continue;
                }

                if (quantityToLoad > mainInventoryItem.cantidad) {
                    validationErrors.push(`Error: La cantidad a cargar de "${mainInventoryItem.producto}" (${quantityToLoad}) excede el stock disponible en el inventario principal (${mainInventoryItem.cantidad}).`);
                    continue;
                }

                // Deduct from main inventory
                mainInventoryItem.cantidad -= quantityToLoad;
                totalLoadAmount += quantityToLoad * mainInventoryItem.precio; // Sumar al total de la carga

                // Add to truck inventory
                const truckItemIndex = updatedTruckInventory.findIndex(item => item.sku === sku);
                if (truckItemIndex !== -1) {
                    updatedTruckInventory[truckItemIndex].quantity += quantityToLoad;
                } else {
                    updatedTruckInventory.push({
                        sku: mainInventoryItem.sku,
                        rubro: mainInventoryItem.rubro,
                        segmento: mainInventoryItem.segmento,
                        producto: mainInventoryItem.producto,
                        presentacion: mainInventoryItem.presentacion,
                        quantity: quantityToLoad,
                        price: mainInventoryItem.precio
                    });
                }

                loadData.push({
                    sku: mainInventoryItem.sku,
                    producto: mainInventoryItem.producto,
                    presentacion: mainInventoryItem.presentacion,
                    cantidadCargada: quantityToLoad,
                    precioUnitario: mainInventoryItem.precio,
                    subtotal: quantityToLoad * mainInventoryItem.precio
                });
            }

            if (validationErrors.length > 0) {
                showMessageModal(validationErrors.join('\n'));
                return;
            }
            if (!hasPositiveLoadQuantity) {
                showMessageModal('Por favor, ingresa al menos una cantidad positiva para cargar.');
                return;
            }

            const fileName = `carga_${selectedTruckForReceiving.plate}_${getCurrentDateFormatted()}.csv`;
            const loadCSVContent = `SKU,Producto,Presentacion,Cantidad Cargada,Precio Unitario,Subtotal\n` +
                                   loadData.map(item => `${item.sku},${item.producto},${item.presentacion},${item.cantidadCargada},${item.precioUnitario.toFixed(2)},${item.subtotal.toFixed(2)}`).join('\n') +
                                   `\nTotal General:, , , , ,${totalLoadAmount.toFixed(2)}`;

            const loadRecord = {
                fileName: fileName,
                date: getCurrentDateFormatted(),
                truckPlate: selectedTruckForReceiving.plate,
                truckName: selectedTruckForReceiving.name,
                loader: selectedLoader,
                total: totalLoadAmount,
                items: loadData,
                rawCSV: loadCSVContent,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            try {
                const batch = db.batch();

                // Update main inventory documents
                updatedMainInventory.forEach(item => {
                    batch.set(db.collection('inventory').doc(item.sku), {
                        rubro: item.rubro, sku: item.sku, segmento: item.segmento,
                        producto: item.producto, presentacion: item.presentacion,
                        cantidad: item.cantidad, precio: item.precio
                    });
                });

                // Update truck inventory document
                batch.set(db.collection('truck_inventories').doc(selectedTruckForReceiving.plate), { items: updatedTruckInventory.filter(item => item.quantity > 0) });

                // Add new load record
                const loadDocRef = db.collection('loadRecords').doc(); // Let Firestore generate ID
                batch.set(loadDocRef, loadRecord);

                await batch.commit();

                // Update local state after successful commit
                inventory = updatedMainInventory; // Update local main inventory
                loadRecords.push({ docId: loadDocRef.id, ...loadRecord }); // Add to local load records
                selectedTruckInventoryForReceiving = updatedTruckInventory; // Update local truck inventory for next operation

                showMessageModal('Mercancía cargada exitosamente. Archivo de carga generado.');
                triggerCSVDownload(fileName, loadCSVContent); // Descargar el CSV
                
                // Reset state for next load
                selectedLoader = null;
                selectedTruckForReceiving = null;
                receivingQuantities = {};
                selectedTruckInventoryForReceiving = [];

                await fetchDataFromFirestore(); // Re-fetch all data to ensure consistency and update UI
                setScreenAndRender('cargaSelection'); // Go back to carga selection screen
            } catch (error) {
                console.error('Error al realizar la carga de mercancía:', error);
                showMessageModal('Error al cargar mercancía. Revisa tu conexión y las reglas de seguridad.');
            }
        };


        const renderResetCargasInicialesPasswordScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden acceder a esta función.'); setScreenAndRender('main'); return; }
            appRoot.innerHTML = createScreenContainer('Confirmación de Seguridad', `
                <p class="text-lg text-center mb-6 text-gray-700">Esta función altera directamente los diversos inventarios (Principal y por vehículo) de la empresa, necesitamos confirmación si desea continuar.</p>
                ${createInput('adminPasswordForReset', 'Contraseña de Administrador', '', 'password', false, '')}
                <button class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-5 rounded-lg w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="handleResetCargasInicialesPassword()">Continuar</button>
                <button class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-5 rounded-lg mt-3 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="setScreenAndRender('cargaSelection')">Cancelar</button>
            `, 'max-w-md mx-auto my-10');
        };

        const handleResetCargasInicialesPassword = async () => {
            const password = document.getElementById('adminPasswordForReset').value;
            if (!password) { showMessageModal('Por favor, ingresa la contraseña.'); return; }
            try {
                await firebase.auth.EmailAuthProvider.credential(currentUser.email, password);
                await loadAllInventoriesForReset();
                setScreenAndRender('resetCargasInicialesEdit');
            } catch (error) {
                showMessageModal(`Error de autenticación: ${error.message}. Contraseña incorrecta o sesión expirada.`);
            }
        };

        const loadAllInventoriesForReset = async () => {
            resetQuantities = {};
            allTruckInventories = {};

            const mainInvSnapshot = await db.collection('inventory').get();
            inventory = mainInvSnapshot.docs.map(doc => ({ sku: doc.id, ...doc.data() }));
            inventory.forEach(item => { resetQuantities[item.sku] = { main: item.cantidad, trucks: {} }; });

            const truckInvSnapshot = await db.collection('truck_inventories').get();
            truckInvSnapshot.docs.forEach(doc => {
                const truckPlate = doc.id;
                const items = doc.data().items || [];
                allTruckInventories[truckPlate] = items;
                items.forEach(item => {
                    if (!resetQuantities[item.sku]) resetQuantities[item.sku] = { main: 0, trucks: {} };
                    resetQuantities[item.sku].trucks[truckPlate] = item.quantity;
                });
            });

            Object.keys(resetQuantities).forEach(sku => {
                vehicles.forEach(vehicle => {
                    if (resetQuantities[sku].trucks[vehicle.plate] === undefined) {
                        resetQuantities[sku].trucks[vehicle.plate] = 0;
                    }
                });
            });
        };

        const renderResetCargasInicialesEditScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden acceder a esta función.'); setScreenAndRender('main'); return; }

            let tableHeaders = `<th>SKU</th><th>Producto</th><th>Principal</th>`;
            vehicles.forEach(v => { tableHeaders += `<th>${v.plate}</th>`; });

            let tableRows = Object.keys(resetQuantities).sort().map(sku => {
                const productDetails = inventory.find(item => item.sku === sku) || { producto: 'Desconocido', presentacion: '' };
                let truckInputs = vehicles.map(v => {
                    const truckQty = resetQuantities[sku].trucks[v.plate] !== undefined ? resetQuantities[sku].trucks[v.plate] : 0;
                    return `<td><input type="number" class="border border-gray-300 rounded-md text-center w-20" value="${truckQty}" onchange="handleResetQuantityChange('${sku}', '${v.plate}', this.value)" min="0"></td>`;
                }).join('');
                return `
                    <tr>
                        <td>${sku}</td>
                        <td>${productDetails.producto}</td>
                        <td><input type="number" class="border border-gray-300 rounded-md text-center w-20" value="${resetQuantities[sku].main}" onchange="handleResetQuantityChange('${sku}', 'main', this.value)" min="0"></td>
                        ${truckInputs}
                    </tr>
                `;
            }).join('');

            appRoot.innerHTML = createScreenContainer('RESET DE CARGAS INICIALES', `
                <p class="text-base text-center my-5 text-gray-600">Modifica las cantidades del inventario principal y de cada camión. Asegúrate de que la suma de las cantidades de un SKU en todos los camiones no exceda la cantidad en el inventario principal.</p>
                ${createTable([tableHeaders], tableRows, 'reset-inventories-body')}
                <button class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-5 rounded-lg mt-5 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="saveResetCargasIniciales()">Guardar Cambios de Inventario</button>
                <button class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-5 rounded-lg mt-3 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="setScreenAndRender('cargaSelection')">Cancelar y Volver</button>
            `);
        };

        const handleResetQuantityChange = (sku, type, value) => {
            const parsedValue = parseInt(value) || 0;
            if (type === 'main') {
                resetQuantities[sku].main = parsedValue;
            } else {
                resetQuantities[sku].trucks[type] = parsedValue;
            }
        };

        const saveResetCargasIniciales = async () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden guardar cambios en esta función.'); return; }
            let validationErrors = [];
            let updatedMainInventory = [];
            let updatedTruckInventories = vehicles.reduce((acc, v) => ({ ...acc, [v.plate]: [] }), {});

            for (const sku of Object.keys(resetQuantities)) {
                const mainQty = resetQuantities[sku].main;
                let totalTruckQty = Object.values(resetQuantities[sku].trucks).reduce((sum, qty) => sum + qty, 0);

                if (totalTruckQty > mainQty) {
                    validationErrors.push(`Error de coherencia para SKU ${sku}: La suma de cantidades en camiones (${totalTruckQty}) excede la cantidad en el inventario principal (${mainQty}).`);
                }

                const originalItemDetails = inventory.find(item => item.sku === sku) || { rubro: 'Desconocido', segmento: 'Desconocido', producto: `Producto ${sku}`, presentacion: 'Unidad', precio: 0 };
                updatedMainInventory.push({ ...originalItemDetails, sku: sku, cantidad: mainQty });

                for (const truckPlate in resetQuantities[sku].trucks) {
                    const truckQty = resetQuantities[sku].trucks[truckPlate];
                    if (truckQty > 0) {
                        const productDetails = inventory.find(item => item.sku === sku) || originalItemDetails;
                        if (productDetails) {
                            updatedTruckInventories[truckPlate].push({
                                sku: productDetails.sku, rubro: productDetails.rubro, segmento: productDetails.segmento,
                                producto: productDetails.producto, presentacion: productDetails.presentacion,
                                quantity: truckQty, price: productDetails.precio
                            });
                        }
                    }
                }
            }

            if (validationErrors.length > 0) { showMessageModal(`Errores de validación:\n${validationErrors.join('\n')}`); return; }

            try {
                const batch = db.batch();
                // Corrected logic for saving reset quantities:
                updatedMainInventory.forEach(item => {
                    batch.set(db.collection('inventory').doc(item.sku), {
                        rubro: item.rubro,
                        sku: item.sku,
                        segmento: item.segmento,
                        producto: item.producto,
                        presentacion: item.presentacion,
                        cantidad: item.cantidad,
                        precio: item.precio
                    });
                });

                for (const truckPlate in updatedTruckInventories) {
                    batch.set(db.collection('truck_inventories').doc(truckPlate), { items: updatedTruckInventories[truckPlate] });
                }

                await batch.commit();
                await fetchDataFromFirestore(); // Re-fetch to update local state
                showMessageModal('Inventarios reiniciados y guardados exitosamente.');
                setScreenAndRender('cargaSelection');
            } catch (error) {
                console.error('Error al guardar los cambios de carga iniciales:', error);
                showMessageModal('Error al guardar los cambios de carga iniciales. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const renderAdminInventorySelection = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden acceder a esta sección de inventario.'); setScreenAndRender('main'); return; }
            appRoot.innerHTML = createScreenContainer('SELECCIÓN DE INVENTARIO (ADMIN)', `
                <p class="text-base text-center my-5 text-gray-600">Selecciona qué inventario deseas visualizar o gestionar.</p>
                <div class="flex flex-wrap justify-center gap-4">
                    ${createButton('INVENTARIO PRINCIPAL', "setScreenAndRender('adminMainInventory')")}
                    ${createButton('INVENTARIO POR VEHÍCULO', "setScreenAndRender('adminVehicleInventory')")}
                </div>
                ${createButton('Volver', "setScreenAndRender('main')", 'bg-gray-600 mt-5 w-full')}
            `);
        };

        const renderAdminMainInventoryScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden ver el inventario principal.'); setScreenAndRender('main'); return; }
            const tableRows = inventory.map(item => `
                <td>${item.rubro}</td><td>${item.sku}</td><td>${item.producto}</td>
                <td>${item.presentacion}</td><td>${item.cantidad}</td><td>$${item.precio.toFixed(2)}</td>
            `).map(row => `<tr>${row}</tr>`).join('');

            appRoot.innerHTML = createScreenContainer('INVENTARIO PRINCIPAL (ALMACÉN)', `
                <p class="text-base text-center mb-4 text-gray-700">Mostrando inventario del almacén principal.</p>
                ${createTable(['Rubro', 'Sku', 'Producto', 'Presentación', 'Cantidad', 'Precio'], tableRows, 'main-inventory-display-body')}
                ${createButton('Volver', "setScreenAndRender('adminInventorySelection')", 'bg-gray-600 mt-5 w-full')}
            `);
        };

        const renderInventarioScreen = () => {
            if (!isUser()) { showMessageModal('Acceso denegado: Solo los usuarios pueden acceder a esta sección de inventario.'); setScreenAndRender('main'); return; }
            appRoot.innerHTML = createScreenContainer('INVENTARIO DE MI CAMIÓN', `
                <div class="mb-4 p-4 bg-blue-50 rounded-lg border border-blue-300">
                    <label for="inventorySearchInputUser" class="block text-lg font-semibold text-blue-700 mb-2">Buscar Producto:</label>
                    ${createInput('inventorySearchInputUser', 'Buscar por SKU, Producto o Presentación...', inventorySearchTermUser, 'text', false, 'filterInventoryForUserScreen(this.value)')}
                </div>
                <div id="inventory-content"></div>
                ${createButton('Volver', "setScreenAndRender('main')", 'bg-gray-600 mt-5 w-full')}
            `);
            updateUserInventoryDisplayTable();
        };

        const filterInventoryForUserScreen = (term) => {
            inventorySearchTermUser = term;
            updateUserInventoryDisplayTable();
        };

        const updateUserInventoryDisplayTable = () => {
            const inventoryContentDiv = document.getElementById('inventory-content');
            if (!inventoryContentDiv) return;

            if (!currentUserData.assignedTruckPlate) {
                inventoryContentDiv.innerHTML = `<p class="text-center text-red-600 text-lg py-4">Todavía no tienes un vehículo asignado.</p><p class="text-center text-gray-600 text-md">Por favor, contacta a un administrador para que te asigne uno.</p>`;
                return;
            }

            const filteredInventory = currentTruckInventory.filter(item =>
                item.sku.toLowerCase().includes(inventorySearchTermUser.toLowerCase()) ||
                item.producto.toLowerCase().includes(inventorySearchTermUser.toLowerCase()) ||
                item.presentacion.toLowerCase().includes(inventorySearchTermUser.toLowerCase())
            );

            let tableRows = '';
            if (filteredInventory.length === 0) {
                tableRows = `<td colspan="6" class="text-center text-gray-500 py-4">No se encontraron productos que coincidan con la búsqueda.</td>`;
            } else {
                tableRows = filteredInventory.map(item => `
                    <td>${item.rubro}</td><td>${item.sku}</td><td>${item.producto}</td>
                    <td>${item.presentacion}</td><td>${item.quantity}</td><td>$${item.price.toFixed(2)}</td>
                `).map(row => `<tr>${row}</tr>`).join('');
            }

            inventoryContentDiv.innerHTML = `
                <p class="text-base text-center mb-4 text-gray-700">Mostrando inventario de tu camión (${currentUserData.assignedTruckPlate})</p>
                ${createTable(['Rubro', 'Sku', 'Producto', 'Presentación', 'Cantidad', 'Precio'], tableRows, 'inventory-display-body')}
            `;
        };

        const renderAdminVehicleInventoryScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden acceder a esta sección.'); setScreenAndRender('main'); return; }

            const vehicleOptions = vehicles.map(v => ({ value: v.plate, text: `${v.name} (${v.plate})` }));
            let displayContent = selectedAdminVehicleForInventory ? `<p class="text-center text-gray-600 text-lg py-4">Cargando inventario para ${selectedAdminVehicleForInventory.name}...</p>` : '<p class="text-center text-gray-600 text-lg py-4">Seleccione un camión para ver su inventario.</p>';

            appRoot.innerHTML = createScreenContainer('INVENTARIO POR VEHÍCULO (ADMIN)', `
                <div class="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-300">
                    <label for="adminVehicleSelect" class="block text-lg font-semibold text-blue-700 mb-2">Seleccionar Camión:</label>
                    ${createSelect('adminVehicleSelect', vehicleOptions, selectedAdminVehicleForInventory?.plate, 'handleAdminVehicleSelection(this.value)')}
                </div>
                <div id="selected-vehicle-inventory-display">${displayContent}</div>
                ${createButton('Volver', "setScreenAndRender('adminInventorySelection')", 'bg-gray-600 mt-5 w-full')}
            `);

            // If a vehicle is already selected, set up the listener immediately
            if (selectedAdminVehicleForInventory) {
                setupAdminTruckInventoryListener(selectedAdminVehicleForInventory.plate);
            } else {
                // Ensure no listener is active if no truck is selected
                if (adminTruckInventoryUnsubscribe) {
                    adminTruckInventoryUnsubscribe();
                    adminTruckInventoryUnsubscribe = null;
                }
            }
        };

        const handleAdminVehicleSelection = (plate) => {
            selectedAdminVehicleForInventory = plate ? vehicles.find(v => v.plate === plate) : null;
            if (selectedAdminVehicleForInventory) {
                setupAdminTruckInventoryListener(plate); // Set up listener for the selected truck
            } else {
                // If no truck is selected, unsubscribe and clear display
                if (adminTruckInventoryUnsubscribe) {
                    adminTruckInventoryUnsubscribe();
                    adminTruckInventoryUnsubscribe = null;
                    console.log('[Firestore Listener] Unsubscribed from admin truck inventory listener (no truck selected).');
                }
                document.getElementById('selected-vehicle-inventory-display').innerHTML = '<p class="text-center text-gray-600 text-lg py-4">Seleccione un camión para ver su inventario.</p>';
            }
        };

        const renderClientesScreen = () => {
            const zonaOptions = zonesData.map(z => ({ value: z.name, text: z.name }));
            const sectorOptions = sectorsData.map(s => ({ value: s.name, text: s.name }));

            appRoot.innerHTML = createScreenContainer('CLIENTES', `
                <div class="mb-4 p-4 bg-blue-50 rounded-lg border border-blue-300">
                    <label for="clientSearchInputClientes" class="block text-lg font-semibold text-blue-700 mb-2">Buscar Cliente:</label>
                    ${createInput('clientSearchInputClientes', 'Buscar por Nombre Comercial o Personal...', clientSearchTermClientes, 'text', false, 'filterClientsForClientesScreen(this.value)')}
                </div>
                <div class="mb-8 p-4 bg-emerald-50 rounded-lg border border-emerald-300">
                    <h3 class="text-xl font-bold mb-4 text-emerald-700">Lista de Clientes</h3>
                    ${createTable(['ID', 'Nombre Comercial', 'Nombre Personal', 'Zona', 'Sector', 'Teléfono', 'Observaciones', 'Acciones'], '', 'client-table-body')}
                </div>
                ${(isAdmin() || isUser()) ? `
                <div class="p-4 bg-lime-50 rounded-lg border border-lime-300">
                    <h3 class="text-xl font-bold mb-4 text-lime-700">Opciones de Cliente</h3>
                    <button class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-3 px-5 rounded-lg mt-3 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="toggleAddClientForm()">Agregar Nuevo Cliente</button>
                    <div id="add-client-form-container" style="display: ${showAddClientForm ? 'block' : 'none'};">
                        <h4 class="text-lg font-bold mt-5 mb-3 text-lime-800">Formulario de Nuevo Cliente</h4>
                        ${createInput('newClientNombreComercial', 'Nombre Comercial', '')}
                        ${createInput('newClientNombrePersonal', 'Nombre Personal', '')}
                        ${createSelect('newClientZona', zonaOptions, '')}
                        ${createSelect('newClientSector', sectorOptions, '')}
                        ${createInput('newClientTlf', 'Teléfono', '', 'tel')}
                        ${createInput('newClientObservaciones', 'Observaciones', '')}
                        <button class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-5 rounded-lg mt-3 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="handleAddClient()">Guardar Nuevo Cliente</button>
                    </div>
                </div>` : ''}
                ${isAdmin() ? `
                <div class="p-4 bg-orange-50 rounded-lg border border-orange-300 mt-5">
                    <h3 class="text-xl font-bold mb-4 text-orange-700">Gestionar Zonas y Sectores (Admin)</h3>
                    <button class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-3 px-5 rounded-lg w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="openManageZonesSectorsModal()">Gestionar Zonas y Sectores</button>
                </div>` : ''}
                ${createButton('Volver', "setScreenAndRender('main')", 'bg-gray-600 mt-5 w-full')}
            `);
            updateClientTableForClientesScreen();
        };

        const filterClientsForClientesScreen = (term) => {
            clientSearchTermClientes = term;
            updateClientTableForClientesScreen();
        };

        const updateClientTableForClientesScreen = () => {
            const clientTableBody = document.getElementById('client-table-body');
            if (!clientTableBody) return;
            clientTableBody.innerHTML = '';
            const filteredClients = clients.filter(client =>
                client.nombreComercial.toLowerCase().includes(clientSearchTermClientes.toLowerCase()) ||
                client.nombrePersonal.toLowerCase().includes(clientSearchTermClientes.toLowerCase())
            );

            if (filteredClients.length === 0) {
                clientTableBody.innerHTML = `<td colspan="8" class="text-center text-gray-500 py-4">No se encontraron clientes.</td>`;
            } else {
                clientTableBody.innerHTML = filteredClients.map(client => `
                    <td>${client.id}</td><td>${client.nombreComercial}</td><td>${client.nombrePersonal}</td>
                    <td>${client.zona}</td><td>${client.sector}</td><td>${client.tlf}</td>
                    <td>${client.observaciones}</td>
                    <td><button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-2 rounded-md text-sm" onclick="openEditClientModal(${JSON.stringify(client).replace(/"/g, '&quot;')})">Editar</button></td>
                `).map(row => `<tr>${row}</tr>`).join('');
            }
        };

        const toggleAddClientForm = () => {
            showAddClientForm = !showAddClientForm;
            render();
        };

        const handleAddClient = async () => {
            const nombreComercial = document.getElementById('newClientNombreComercial').value;
            const nombrePersonal = document.getElementById('newClientNombrePersonal').value;
            const zona = document.getElementById('newClientZona').value;
            const sector = document.getElementById('newClientSector').value;
            const tlf = document.getElementById('newClientTlf').value;
            const observaciones = document.getElementById('newClientObservaciones').value;

            if (!nombreComercial || !nombrePersonal || !tlf) { showMessageModal('Error: Nombre Comercial, Nombre Personal y Teléfono son obligatorios.'); return; }

            try {
                const newClientId = `client_${Date.now()}`;
                const newClientData = { id: newClientId, nombreComercial, nombrePersonal, zona, sector, tlf, observaciones };
                await db.collection('clients').doc(newClientId).set(newClientData);
                clients.push(newClientData);
                showMessageModal('Cliente Agregado: El nuevo cliente ha sido añadido a Firestore.');
                document.getElementById('newClientNombreComercial').value = '';
                document.getElementById('newClientNombrePersonal').value = '';
                document.getElementById('newClientZona').value = '';
                document.getElementById('newClientSector').value = '';
                document.getElementById('newClientTlf').value = '';
                document.getElementById('newClientObservaciones').value = '';
                showAddClientForm = false;
                setScreenAndRender('clientes');
            } catch (error) {
                console.error('Error al añadir cliente a Firestore:', error);
                showMessageModal('Error al agregar cliente. Por favor, revisa tu conexión y las reglas de seguridad.');
            }
        };

        const openEditClientModal = (client) => {
            editingClient = JSON.parse(JSON.stringify(client));
            originalEditingClientId = client.id || '';
            showEditClientModal = true;
            render();
        };

        const closeEditClientModal = () => {
            editingClient = null;
            originalEditingClientId = null;
            showEditClientModal = false;
            render();
        };

        const handleEditClientChange = (field, value) => {
            if (editingClient) editingClient[field] = value;
        };

        const saveEditedClient = async () => {
            if (!editingClient) return;
            const clientToSave = editingClient;
            if (!clientToSave.nombreComercial || !clientToSave.nombrePersonal || !clientToSave.tlf) { showMessageModal('Error: Nombre Comercial, Nombre Personal y Teléfono son obligatorios.'); return; }

            const isIdChanged = isAdmin() && clientToSave.id !== originalEditingClientId;

            if (isIdChanged) {
                showConfirmationModal(
                    `El ID del cliente ha cambiado de "${originalEditingClientId}" a "${clientToSave.id}". Esto creará un nuevo cliente y eliminará el antiguo. Las ventas históricas asociadas al ID antiguo NO se actualizarán automáticamente. ¿Deseas continuar?`,
                    async () => {
                        if (!originalEditingClientId || originalEditingClientId.trim() === '') {
                            showMessageModal('Error interno: El ID del cliente original es inválido. No se puede realizar el cambio de ID.'); return;
                        }
                        try {
                            const batch = db.batch();
                            batch.set(db.collection('clients').doc(clientToSave.id), clientToSave);
                            batch.delete(db.collection('clients').doc(originalEditingClientId));
                            await batch.commit();
                            clients = clients.filter(c => c.id !== originalEditingClientId);
                            clients.push(clientToSave);
                            showMessageModal('Cliente actualizado exitosamente (ID cambiado). Las ventas históricas no se actualizaron.');
                            closeEditClientModal();
                            setScreenAndRender('clientes');
                        } catch (error) {
                            console.error('Error al actualizar cliente (cambio de ID) en Firestore:', error);
                            showMessageModal('Error al actualizar cliente (cambio de ID). Por favor, revisa tu conexión y las reglas de seguridad.');
                        }
                    }
                );
            } else {
                try {
                    await db.collection('clients').doc(clientToSave.id).set(clientToSave);
                    clients = clients.map(c => c.id === clientToSave.id ? clientToSave : c);
                    showMessageModal('Cliente actualizado exitosamente.');
                    closeEditClientModal();
                    setScreenAndRender('clientes');
                } catch (error) {
                    console.error('Error al actualizar cliente en Firestore:', error);
                    showMessageModal('Error al actualizar cliente. Por favor, revisa tu conexión y las reglas de seguridad.');
                }
            }
        };

        const renderEditClientModal = () => {
            if (!showEditClientModal || !editingClient) return '';
            const zonaOptions = zonesData.map(z => ({ value: z.name, text: z.name }));
            const sectorOptions = sectorsData.map(s => ({ value: s.name, text: s.name }));

            return `
                <div id="edit-client-modal" class="modal">
                    <div class="modal-content">
                        <h3 class="text-2xl font-bold mb-4 text-center text-indigo-700">Editar Cliente</h3>
                        ${createInput('editClientId', 'ID del Cliente', editingClient.id, 'text', !isAdmin(), "handleEditClientChange('id', this.value)")}
                        ${createInput('editClientNombreComercial', 'Nombre Comercial', editingClient.nombreComercial, 'text', false, "handleEditClientChange('nombreComercial', this.value)")}
                        ${createInput('editClientNombrePersonal', 'Nombre Personal', editingClient.nombrePersonal, 'text', false, "handleEditClientChange('nombrePersonal', this.value)")}
                        ${createSelect('editClientZona', zonaOptions, editingClient.zona, "handleEditClientChange('zona', this.value)")}
                        ${createSelect('editClientSector', sectorOptions, editingClient.sector, "handleEditClientChange('sector', this.value)")}
                        ${createInput('editClientTlf', 'Teléfono', editingClient.tlf, 'tel', false, "handleEditClientChange('tlf', this.value)")}
                        ${createInput('editClientObservaciones', 'Observaciones', editingClient.observaciones, 'text', false, "handleEditClientChange('observaciones', this.value)")}
                        <div class="flex justify-around gap-4 mt-5">
                            <button class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-5 rounded-lg flex-1 shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="saveEditedClient()">Guardar Cambios</button>
                            <button class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-5 rounded-lg flex-1 shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="closeEditClientModal()">Cancelar</button>
                        </div>
                    </div>
                </div>
            `;
        };

        const openManageZonesSectorsModal = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden gestionar zonas y sectores.'); return; }
            showManageZonesSectorsModalState = true;
            editingZone = null;
            editingSector = null;
            render();
        };

        const closeManageZonesSectorsModal = () => {
            showManageZonesSectorsModalState = false;
            editingZone = null;
            editingSector = null;
            render();
        };

        const renderManageZonesSectorsModal = () => {
            if (!showManageZonesSectorsModalState) return '';
            return `
                <div id="manage-zones-sectors-modal" class="modal">
                    <div class="modal-content">
                        <h3 class="text-2xl font-bold mb-4 text-center text-indigo-700">Gestionar Zonas y Sectores</h3>
                        <div class="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-300">
                            <h4 class="text-xl font-bold mb-3 text-blue-700">Zonas</h4>
                            <div id="zones-list" class="mb-4 max-h-40 overflow-y-auto border border-gray-200 rounded-md p-2"></div>
                            ${createInput('zoneNameInput', 'Nombre de la nueva zona', editingZone ? editingZone.name : '', 'text', false, '')}
                            <div class="flex gap-2">
                                <button class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md flex-1" onclick="${editingZone ? 'saveEditedZone()' : 'addZone()'}">${editingZone ? 'Guardar Zona' : 'Agregar Zona'}</button>
                                ${editingZone ? `<button class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-md flex-1" onclick="cancelEditZone()">Cancelar</button>` : ''}
                            </div>
                        </div>
                        <div class="mb-6 p-4 bg-purple-50 rounded-lg border border-purple-300">
                            <h4 class="text-xl font-bold mb-3 text-purple-700">Sectores</h4>
                            <div id="sectors-list" class="mb-4 max-h-40 overflow-y-auto border border-gray-200 rounded-md p-2"></div>
                            ${createInput('sectorNameInput', 'Nombre del nuevo sector', editingSector ? editingSector.name : '', 'text', false, '')}
                            <div class="flex gap-2">
                                <button class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md flex-1" onclick="${editingSector ? 'saveEditedSector()' : 'addSector()'}">${editingSector ? 'Guardar Sector' : 'Agregar Sector'}</button>
                                ${editingSector ? `<button class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-md flex-1" onclick="cancelEditSector()">Cancelar</button>` : ''}
                            </div>
                        </div>
                        <button class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-5 rounded-lg mt-5 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="closeManageZonesSectorsModal()">Cerrar</button>
                    </div>
                </div>
            `;
        };

        const updateZonesList = () => {
            const zonesListDiv = document.getElementById('zones-list');
            if (!zonesListDiv) return;
            zonesListDiv.innerHTML = zonesData.map(zone => `
                <div class="flex justify-between items-center bg-white p-2 mb-1 rounded-md border border-gray-200">
                    <span>${zone.name}</span>
                    <div>
                        <button class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-2 rounded-md text-sm mr-1" onclick="editZone('${zone.name}')">Editar</button>
                        <button class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-2 rounded-md text-sm" onclick="showDeleteZoneConfirmation('${zone.name}')">Eliminar</button>
                    </div>
                </div>
            `).join('');
        };

        const updateSectorsList = () => {
            const sectorsListDiv = document.getElementById('sectors-list');
            if (!sectorsListDiv) return;
            sectorsListDiv.innerHTML = sectorsData.map(sector => `
                <div class="flex justify-between items-center bg-white p-2 mb-1 rounded-md border border-gray-200">
                    <span>${sector.name}</span>
                    <div>
                        <button class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-2 rounded-md text-sm mr-1" onclick="editSector('${sector.name}')">Editar</button>
                        <button class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-2 rounded-md text-sm" onclick="showDeleteSectorConfirmation('${sector.name}')">Eliminar</button>
                    </div>
                </div>
            `).join('');
        };

        const addZone = async () => {
            const name = document.getElementById('zoneNameInput').value.trim();
            if (!name) { showMessageModal('El nombre de la zona no puede estar vacío.'); return; }
            if (zonesData.some(z => z.name === name)) { showMessageModal('Ya existe una zona con ese nombre.'); return; }
            try {
                await db.collection('zones').doc(name).set({ name: name });
                zonesData.push({ name: name });
                zonesData.sort((a, b) => a.name.localeCompare(b.name));
                document.getElementById('zoneNameInput').value = '';
                updateZonesList();
                showMessageModal('Zona agregada exitosamente.');
                setScreenAndRender('clientes');
                openManageZonesSectorsModal();
            } catch (error) {
                console.error('Error al agregar zona:', error);
                showMessageModal('Error al agregar zona. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const editZone = (name) => {
            editingZone = zonesData.find(z => z.name === name);
            render();
            openManageZonesSectorsModal();
        };

        const cancelEditZone = () => {
            editingZone = null;
            document.getElementById('zoneNameInput').value = '';
            render();
            openManageZonesSectorsModal();
        };

        const saveEditedZone = async () => {
            if (!editingZone) return;
            const newName = document.getElementById('zoneNameInput').value.trim();
            if (!newName) { showMessageModal('El nombre de la zona no puede estar vacío.'); return; }
            if (newName !== editingZone.name && zonesData.some(z => z.name === newName)) { showMessageModal('Ya existe una zona con el nuevo nombre.'); return; }
            try {
                if (newName !== editingZone.name) {
                    await db.collection('zones').doc(newName).set({ name: newName });
                    await db.collection('zones').doc(editingZone.name).delete();
                    const clientsWithOldZone = await db.collection('clients').where('zona', '==', editingZone.name).get();
                    const batch = db.batch();
                    clientsWithOldZone.docs.forEach(doc => batch.update(db.collection('clients').doc(doc.id), { zona: newName }));
                    await batch.commit();
                    clients = clients.map(client => client.zona === editingZone.name ? { ...client, zona: newName } : client);
                } else {
                    await db.collection('zones').doc(newName).set({ name: newName });
                }
                zonesData = zonesData.filter(z => z.name !== editingZone.name);
                zonesData.push({ name: newName });
                zonesData.sort((a, b) => a.name.localeCompare(b.name));
                editingZone = null;
                showMessageModal('Zona actualizada exitosamente.');
                setScreenAndRender('clientes');
                openManageZonesSectorsModal();
            } catch (error) {
                console.error('Error al guardar zona:', error);
                showMessageModal('Error al guardar zona. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const showDeleteZoneConfirmation = (name) => {
            showConfirmationModal(`¿Estás seguro de que quieres eliminar la zona "${name}"? Esto no actualizará automáticamente los clientes asociados.`, () => deleteZone(name));
        };

        const deleteZone = async (name) => {
            try {
                await db.collection('zones').doc(name).delete();
                zonesData = zonesData.filter(z => z.name !== name);
                showMessageModal('Zona eliminada exitosamente.');
                updateZonesList();
                setScreenAndRender('clientes');
                openManageZonesSectorsModal();
            } catch (error) {
                console.error('Error al eliminar zona:', error);
                showMessageModal('Error al eliminar zona. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const addSector = async () => {
            const name = document.getElementById('sectorNameInput').value.trim();
            if (!name) { showMessageModal('El nombre del sector no puede estar vacío.'); return; }
            if (sectorsData.some(s => s.name === name)) { showMessageModal('Ya existe un sector con ese nombre.'); return; }
            try {
                await db.collection('sectors').doc(name).set({ name: name });
                sectorsData.push({ name: name });
                sectorsData.sort((a, b) => a.name.localeCompare(b.name));
                document.getElementById('sectorNameInput').value = '';
                updateSectorsList();
                showMessageModal('Sector agregado exitosamente.');
                setScreenAndRender('clientes');
                openManageZonesSectorsModal();
            } catch (error) {
                console.error('Error al agregar sector:', error);
                showMessageModal('Error al agregar sector. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const editSector = (name) => {
            editingSector = sectorsData.find(s => s.name === name);
            render();
            openManageZonesSectorsModal();
        };

        const cancelEditSector = () => {
            editingSector = null;
            document.getElementById('sectorNameInput').value = '';
            render();
            openManageZonesSectorsModal();
        };

        const saveEditedSector = async () => {
            if (!editingSector) return;
            const newName = document.getElementById('sectorNameInput').value.trim();
            if (!newName) { showMessageModal('El nombre del sector no puede estar vacío.'); return; }
            if (newName !== editingSector.name && sectorsData.some(s => s.name === newName)) { showMessageModal('Ya existe un sector con el nuevo nombre.'); return; }
            try {
                if (newName !== editingSector.name) {
                    await db.collection('sectors').doc(newName).set({ name: newName });
                    await db.collection('sectors').doc(editingSector.name).delete();
                    const clientsWithOldSector = await db.collection('clients').where('sector', '==', editingSector.name).get();
                    const batch = db.batch();
                    clientsWithOldSector.docs.forEach(doc => batch.update(db.collection('clients').doc(doc.id), { sector: newName }));
                    await batch.commit();
                    clients = clients.map(client => client.sector === editingSector.name ? { ...client, sector: newName } : client);
                } else {
                    await db.collection('sectors').doc(newName).set({ name: newName });
                }
                sectorsData = sectorsData.filter(s => s.name !== editingSector.name);
                sectorsData.push({ name: newName });
                sectorsData.sort((a, b) => a.name.localeCompare(b.name));
                editingSector = null;
                showMessageModal('Sector actualizado exitosamente.');
                setScreenAndRender('clientes');
                openManageZonesSectorsModal();
            } catch (error) {
                console.error('Error al guardar sector:', error);
                showMessageModal('Error al guardar sector. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const showDeleteSectorConfirmation = (name) => {
            showConfirmationModal(`¿Estás seguro de que quieres eliminar el sector "${name}"? Esto no actualizará automáticamente los clientes asociados.`, () => deleteSector(name));
        };

        const deleteSector = async (name) => {
            try {
                await db.collection('sectors').doc(name).delete();
                sectorsData = sectorsData.filter(s => s.name !== name);
                showMessageModal('Sector eliminada exitosamente.');
                updateSectorsList();
                setScreenAndRender('clientes');
                openManageZonesSectorsModal();
            } catch (error) {
                console.error('Error al eliminar sector:', error);
                showMessageModal('Error al eliminar sector. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const renderVentaScreen = () => {
            console.log('[renderVentaScreen] Rendering venta screen.');
            appRoot.innerHTML = createScreenContainer('VENTA', `
                <button class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-5 rounded-lg w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="toggleClientPickerModal(true)">Seleccionar Cliente</button>
                <div id="selected-client-display" class="text-lg font-bold text-center my-4 text-emerald-800"></div>
                <div id="product-sale-container"></div>
                <div id="info-text" class="text-base text-center my-5 text-gray-600"></div>
                ${createButton('Volver al Menú Principal', "resetVentaStateAndGoToMain()", 'bg-gray-600 mt-5 w-full')}
            `);
            updateVentaScreenContent();
        };

        const updateVentaScreenContent = () => {
            console.log('[updateVentaScreenContent] Updating venta screen content.');
            const selectedClientDisplay = document.getElementById('selected-client-display');
            const productSaleContainer = document.getElementById('product-sale-container');
            const infoText = document.getElementById('info-text');

            if (isUser() && !currentUserData.assignedTruckPlate) {
                selectedClientDisplay.textContent = '';
                infoText.textContent = 'No tienes un camión asignado. Por favor, contacta a un administrador para que te asigne uno.';
                productSaleContainer.innerHTML = '';
                return;
            }

            // Always display currentTruckInventory for users, or main inventory for admin if no truck assigned.
            const inventoryToDisplay = currentUserData.assignedTruckPlate ? currentTruckInventory : inventory;
            const inventorySourceText = currentUserData.assignedTruckPlate ? ` (Camión: ${currentUserData.assignedTruckPlate})` : ' (Almacén Principal)';

            if (selectedClientForSale) {
                selectedClientDisplay.textContent = `Cliente Seleccionado: ${selectedClientForSale.nombreComercial}`;
                infoText.textContent = `Inventario actual${inventorySourceText}`;

                const tableRows = inventoryToDisplay.map(item => {
                    const quantity = item.quantity !== undefined ? item.quantity : item.cantidad;
                    const price = item.price !== undefined ? item.price : item.precio;
                    return `
                        <td><img src="${productImages[item.sku] || productImages['default']}" alt="Imagen de ${item.producto}" class="w-10 h-10 rounded-md object-cover"></td>
                        <td>${item.sku}</td>
                        <td><input type="number" class="border border-gray-300 rounded-md text-center" value="${saleQuantities[item.sku] || ''}" onchange="handleProductQuantityChange('${item.sku}', this.value)" min="0" max="${quantity}"></td>
                        <td>${item.producto}</td><td>${item.presentacion}</td><td>$${price.toFixed(2)}</td><td>${quantity}</td>
                    `;
                }).map(row => `<tr>${row}</tr>`).join('');

                productSaleContainer.innerHTML = `
                    ${createTable(['Imagen', 'SKU', 'Cantidad a Vender', 'Producto', 'Presentación', 'Precio', 'Disponible'], tableRows, 'products-for-sale-body')}
                    <button class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-5 rounded-lg mt-3 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="showFinalizeSaleConfirmation()">Finalizar Venta</button>
                `;
            } else {
                selectedClientDisplay.textContent = '';
                infoText.textContent = 'Por favor, seleccione un cliente para iniciar la venta.';
                productSaleContainer.innerHTML = '';
            }
        };

        const handleProductQuantityChange = (sku, quantity) => {
            saleQuantities[sku] = parseInt(quantity) || 0;
        };

        const showFinalizeSaleConfirmation = () => {
            showConfirmationModal('¿Estás seguro de que quieres finalizar esta venta? Esto actualizará el inventario y generará un archivo de venta.', finalizeSaleLogic);
        };

        const finalizeSaleLogic = async () => {
            if (!selectedClientForSale) { showMessageModal('Error: Por favor, seleccione un cliente primero.'); return; }
            if (isUser() && !currentUserData.assignedTruckPlate) { showMessageModal('Error: No tienes un camión asignado para realizar ventas.'); return; }

            const saleData = [];
            let totalSaleAmount = 0;
            let messages = [];
            let validationErrors = [];

            const sourceInventoryCollection = currentUserData.assignedTruckPlate ? 'truck_inventories' : 'inventory';
            const sourceInventoryDocId = currentUserData.assignedTruckPlate;

            let currentSourceInventoryData;
            // When offline, currentTruckInventory will already reflect local changes due to onSnapshot.
            // For validation, we should use the current local state.
            if (sourceInventoryDocId) {
                currentSourceInventoryData = JSON.parse(JSON.stringify(currentTruckInventory)); // Use the current local state for validation
            } else {
                currentSourceInventoryData = JSON.parse(JSON.stringify(inventory));
            }

            let updatedSourceInventory = JSON.parse(JSON.stringify(currentSourceInventoryData));

            for (const item of currentSourceInventoryData) {
                const quantitySold = saleQuantities[item.sku] || 0;
                const availableQuantity = item.quantity !== undefined ? item.quantity : item.cantidad;

                if (quantitySold > 0) {
                    if (quantitySold > availableQuantity) {
                        validationErrors.push(`Error: La cantidad a vender de "${item.producto}" (${quantitySold}) excede el stock disponible (${availableQuantity}).`);
                    } else {
                        const price = item.price !== undefined ? item.price : item.precio;
                        const subtotal = quantitySold * price;
                        saleData.push({ sku: item.sku, producto: item.producto, presentacion: item.presentacion, cantidadVendida: quantitySold, precioUnitario: price, subtotal: subtotal });
                        totalSaleAmount += subtotal;

                        updatedSourceInventory = updatedSourceInventory.map(invItem =>
                            invItem.sku === item.sku ? {
                                ...invItem,
                                quantity: (invItem.quantity !== undefined ? invItem.quantity : invItem.cantidad) - quantitySold,
                                cantidad: (invItem.quantity !== undefined ? invItem.quantity : invItem.cantidad) - quantitySold
                            } : invItem
                        );
                    }
                }
            }

            if (validationErrors.length > 0) { showMessageModal(validationErrors.join('\n')); return; }
            if (saleData.length === 0) { showMessageModal('Error: No se ha ingresado ninguna cantidad para la venta.'); return; }

            const fileName = `venta_${selectedClientForSale.nombreComercial.replace(/\s/g, '_')}_${getCurrentDateFormatted()}.csv`;
            const saleRecord = {
                fileName: fileName, client: selectedClientForSale, date: getCurrentDateFormatted(), items: saleData,
                total: totalSaleAmount, vendor: selectedVendor, sourceInventory: currentUserData.assignedTruckPlate || 'warehouse',
                rawCSV: `SKU,Producto,Presentacion,Cantidad,Precio Unitario,Subtotal\n` +
                        saleData.map(item => `${item.sku},${item.producto},${item.presentacion},${item.cantidadVendida},${item.precioUnitario.toFixed(2)},${item.subtotal.toFixed(2)}`).join('\n') +
                        `\nTotal General:, , , , ,${totalSaleAmount.toFixed(2)}`
            };

            // 1. Update local state immediately for UI responsiveness
            // Assign a temporary ID for local display until Firestore provides a real one
            saleRecord.docId = `temp_${Date.now()}`;
            dailySales.push(saleRecord);

            if (sourceInventoryDocId) {
                // Update local truck inventory directly. The onSnapshot listener will then reflect this.
                currentTruckInventory = updatedSourceInventory.filter(item => (item.quantity !== undefined ? item.quantity : item.cantidad) > 0);
            }
            // No update to main inventory here. It will be updated during Cierre de Ventas.

            // 2. Render UI immediately to reflect changes
            resetVentaState();
            setScreenAndRender('main');
            showMessageModal(`Venta registrada localmente para ${selectedClientForSale.nombreComercial}. Se sincronizará cuando haya conexión a internet.`);

            // 3. Perform Firestore write in background (non-blocking)
            try {
                const batch = db.batch();
                // Let Firestore generate a real ID for the new document
                const docRef = db.collection('dailySales').doc();
                batch.set(docRef, saleRecord); // Use the new docRef for the actual DB write

                if (sourceInventoryDocId) {
                    // Update truck inventory in Firestore
                    batch.set(db.collection('truck_inventories').doc(sourceInventoryDocId), { items: currentTruckInventory });
                }

                await batch.commit(); // Await the commit for proper error handling and real ID assignment
                console.log('Firestore commit successful for sale:', saleRecord.fileName);

                // Update the local saleRecord with the real docId after successful commit
                const index = dailySales.findIndex(s => s.docId === saleRecord.docId);
                if (index !== -1) {
                    dailySales[index].docId = docRef.id;
                }
                // Re-fetch other data (not truck inventory, as onSnapshot handles it)
                await fetchDataFromFirestore();

            } catch (error) {
                console.error('Error al guardar la venta en Firestore (puede ser por falta de conexión):', error);
                // If it's a network error, Firestore handles queuing. If it's another error, notify.
                if (error.code !== 'unavailable' && error.code !== 'internal' && error.code !== 'failed-precondition') { // Common codes for network issues
                    showMessageModal('Error al guardar la venta en la nube. Por favor, revisa tu conexión y las reglas de seguridad de Firestore.');
                }
                // If it's a network error, the sale is still locally present, so no need to revert UI.
            }
        };

        const toggleClientPickerModal = (show) => {
            console.log(`[toggleClientPickerModal] Toggling client picker modal to: ${show}`);
            showClientPickerModal = show;
            render(); // This will trigger the main render function, which now includes the modal.
            if (show) {
                // Call updateClientPickerList *after* render() has updated the DOM
                // to ensure the modal elements exist.
                setTimeout(() => { // Using setTimeout to ensure DOM is updated
                    console.log('[toggleClientPickerModal] Calling updateClientPickerList after timeout.');
                    updateClientPickerList();
                }, 0);
            }
        };

        const renderClientPickerModal = () => {
            console.log('[renderClientPickerModal] Rendering client picker modal.');
            if (!showClientPickerModal) return '';
            return `
                <div id="client-picker-modal" class="modal">
                    <div class="modal-content">
                        <h3 class="text-2xl font-bold mb-4 text-center text-indigo-700">Seleccionar Cliente</h3>
                        ${createInput('clientSearchInput', 'Buscar cliente...', clientSearchTerm, 'text', false, 'filterClientsForPicker(this.value)')}
                        <div id="client-picker-list" class="max-h-60 overflow-y-auto w-full"></div>
                        <button class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-5 rounded-lg mt-5 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="toggleClientPickerModal(false)">Cerrar</button>
                    </div>
                </div>
            `;
        };

        const updateClientPickerList = () => {
            console.log('[updateClientPickerList] Updating client picker list.');
            const clientPickerListDiv = document.getElementById('client-picker-list');
            if (!clientPickerListDiv) {
                console.warn('[updateClientPickerList] client-picker-list element not found.');
                return;
            }
            clientPickerListDiv.innerHTML = '';
            const filteredClients = clients.filter(client =>
                client.nombreComercial.toLowerCase().includes(clientSearchTerm.toLowerCase()) ||
                client.nombrePersonal.toLowerCase().includes(clientSearchTerm.toLowerCase())
            );

            if (filteredClients.length === 0) {
                clientPickerListDiv.innerHTML = `<p class="text-center text-gray-500 py-4">No se encontraron clientes.</p>`;
            } else {
                filteredClients.forEach(client => {
                    const clientItem = document.createElement('button');
                    clientItem.className = 'block w-full text-left p-3 border-b border-gray-200 hover:bg-blue-50 transition duration-150 ease-in-out rounded-md';
                    clientItem.textContent = `${client.nombreComercial} (${client.nombrePersonal})`;
                    clientItem.onclick = () => {
                        selectedClientForSale = client;
                        toggleClientPickerModal(false);
                        clientSearchTerm = '';
                        updateVentaScreenContent();
                    };
                    clientPickerListDiv.appendChild(clientItem);
                });
            }
        };

        const filterClientsForPicker = (term) => {
            clientSearchTerm = term;
            updateClientPickerList();
        };

        const resetVentaState = () => {
            selectedClientForSale = null;
            saleQuantities = {};
            currentProductIndex = 0;
        };

        const resetVentaStateAndGoToMain = () => {
            resetVentaState();
            setScreenAndRender('main');
        };

        const renderCierreVentasScreen = () => {
            // No hay una verificación isAdmin() aquí, ya que el usuario ha especificado que es una función de tipo 'user'.
            appRoot.innerHTML = createScreenContainer('CIERRE DE VENTAS', `
                <div class="mb-8 text-center">
                    <label class="block text-lg font-semibold text-gray-700 mb-2">Seleccionar Vendedor:</label>
                    <div class="radio-button-group" id="vendor-radio-group"></div>
                </div>
                <p class="text-base text-center my-5 text-gray-600">Esta sección permite consolidar y cerrar las ventas del día.</p>
                <button class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-5 rounded-lg mt-3 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="showCloseSalesConfirmation()">Cerrar Ventas del Día</button>
                ${createButton('Volver', "setScreenAndRender('main')", 'bg-gray-600 mt-5 w-full')}
            `);
            updateVendorSelectionDisplay();
        };

        const showCloseSalesConfirmation = () => {
            showConfirmationModal('¿Estás seguro de que quieres cerrar las ventas del día? Esto consolidará las ventas y "borrará" los registros individuales.', handleCloseSalesLogic);
        };

        const handleCloseSalesLogic = async () => {
            console.log('[handleCloseSalesLogic] Initiating sales close logic.');
            let messages = [];
            if (dailySales.length === 0) {
                showMessageModal('No hay Ventas: No hay ventas registradas para cerrar.');
                console.log('[handleCloseSalesLogic] No daily sales found.');
                return;
            }

            const salesByDate = dailySales.reduce((acc, sale) => {
                (acc[sale.date] = acc[sale.date] || []).push(sale);
                return acc;
            }, {});

            let allProcessedSaleDocIds = [];
            // Get a fresh copy of the main inventory, as this is the ONLY place it should be modified
            let updatedMainInventory = JSON.parse(JSON.stringify(inventory));
            console.log('[handleCloseSalesLogic] Initial Main Inventory (before processing sales):', JSON.stringify(updatedMainInventory.map(i => ({sku: i.sku, cantidad: i.cantidad}))));

            // New: Aggregate sales per truck
            const truckSalesAggregates = {};

            for (const date in salesByDate) {
                const salesForThisDate = salesByDate[date];
                const aggregatedSalesBySku = {};
                let totalOverallSale = 0;

                salesForThisDate.forEach(sale => {
                    sale.items.forEach(item => {
                        const { sku, producto, presentacion, cantidadVendida, precioUnitario, subtotal } = item;
                        if (!aggregatedSalesBySku[sku]) {
                            aggregatedSalesBySku[sku] = { producto, presentacion, totalCantidad: 0, totalSubtotal: 0 };
                        }
                        aggregatedSalesBySku[sku].totalCantidad += cantidadVendida;
                        aggregatedSalesBySku[sku].totalSubtotal += subtotal;
                        totalOverallSale += subtotal;
                    });

                    // Aggregate sales for each truck
                    if (sale.sourceInventory && sale.sourceInventory !== 'warehouse') {
                        const truckPlate = sale.sourceInventory;
                        if (!truckSalesAggregates[truckPlate]) {
                            truckSalesAggregates[truckPlate] = {};
                        }
                        sale.items.forEach(item => {
                            truckSalesAggregates[truckPlate][item.sku] = (truckSalesAggregates[truckPlate][item.sku] || 0) + item.cantidadVendida;
                        });
                    }
                });

                // Generate Consolidated CSV
                let combinedCSVContent = `Venta General Consolidada - Fecha: ${date}\nVendedor: ${selectedVendor}\n\nSKU,Producto,Presentacion,Cantidad Total,Subtotal Total\n`;
                for (const sku in aggregatedSalesBySku) {
                    const item = aggregatedSalesBySku[sku];
                    combinedCSVContent += `${sku},${item.producto},${item.presentacion},${item.totalCantidad},${item.totalSubtotal.toFixed(2)}\n`;
                }
                combinedCSVContent += `\nTotal General:, , , ,${totalOverallSale.toFixed(2)}`;
                const combinedFileName = `venta_consolidada_${date}.csv`;
                messages.push(`Cierre de Ventas para ${date}: Se ha generado el archivo "${combinedFileName}" con las ventas consolidadas.\nTotal del día: $${totalOverallSale.toFixed(2)}`);
                console.log(`[handleCloseSalesLogic] Attempting to download consolidated CSV: ${combinedFileName}`);
                triggerCSVDownload(combinedFileName, combinedCSVContent); // Usar la nueva función para descargar

                // Generate Client-specific CSV
                const uniqueSKUs = new Set();
                const clientSalesData = {};
                salesForThisDate.forEach(sale => {
                    if (!clientSalesData[sale.client.id]) {
                        clientSalesData[sale.client.id] = { clientName: sale.client.nombreComercial, total: 0, skus: {} };
                    }
                    sale.items.forEach(item => {
                        uniqueSKUs.add(item.sku);
                        clientSalesData[sale.client.id].skus[item.sku] = (clientSalesData[sale.client.id].skus[item.sku] || 0) + item.cantidadVendida;
                        clientSalesData[sale.client.id].total += item.subtotal;
                    });
                });

                const sortedUniqueSKUs = Array.from(uniqueSKUs).sort();
                let clientCSVContent = `Venta General por Clientes - Fecha: ${date}\nVendedor: ${selectedVendor}\n\nCliente,${sortedUniqueSKUs.map(sku => `SKU(${sku})`).join(',')},Total\n`;
                let grandTotalClients = 0;
                for (const clientId in clientSalesData) {
                    const clientData = clientSalesData[clientId];
                    let clientRow = `"${clientData.clientName}"`;
                    sortedUniqueSKUs.forEach(sku => { clientRow += `,${clientData.skus[sku] || 0}`; });
                    clientRow += `,${clientData.total.toFixed(2)}\n`;
                    clientCSVContent += clientRow;
                    grandTotalClients += clientData.total;
                }
                clientCSVContent += `Total General:,${','.repeat(sortedUniqueSKUs.length)},${grandTotalClients.toFixed(2)}`;
                const clientFileName = `ventas_por_cliente_${date}.csv`;
                messages.push(`Se ha generado el archivo "${clientFileName}" con las ventas consolidadas por cliente para ${date}.`);
                console.log(`[handleCloseSalesLogic] Attempting to download client-specific CSV: ${clientFileName}`);
                triggerCSVDownload(clientFileName, clientCSVContent); // Usar la nueva función para descargar

                // DEDUCT FROM MAIN INVENTORY - This is the ONLY place this should happen
                for (const sku in aggregatedSalesBySku) {
                    const totalQuantitySold = aggregatedSalesBySku[sku].totalCantidad;
                    const mainInventoryItem = updatedMainInventory.find(item => item.sku === sku);
                    if (mainInventoryItem) {
                        console.log(`[handleCloseSalesLogic] Deducting ${totalQuantitySold} of SKU ${sku} from main inventory. Before: ${mainInventoryItem.cantidad}`);
                        mainInventoryItem.cantidad = Math.max(0, mainInventoryItem.cantidad - totalQuantitySold);
                        console.log(`[handleCloseSalesLogic] After deduction: ${mainInventoryItem.cantidad}`);
                    } else {
                        messages.push(`Advertencia: SKU ${sku} vendido no encontrado en el inventario principal para deducción durante el cierre.`);
                        console.warn(`[handleCloseSalesLogic] SKU ${sku} not found in main inventory for deduction.`);
                    }
                }
                salesForThisDate.forEach(sale => {
                    if (sale.docId) {
                        allProcessedSaleDocIds.push(sale.docId);
                        console.log(`[handleCloseSalesLogic] Marking sale DOC ID ${sale.docId} for deletion.`);
                    }
                });
            }

            console.log('[handleCloseSalesLogic] Main Inventory AFTER processing sales (before commit):', JSON.stringify(updatedMainInventory.map(i => ({sku: i.sku, cantidad: i.cantidad}))));

            messages.push(`Compartiendo: Simulando compartir archivos de cierre vía WhatsApp.`);
            messages.push(`Imprimiendo: Simulando impresión del cierre de ventas.`);

            try {
                const batch = db.batch();
                updatedMainInventory.forEach(item => {
                    console.log(`[handleCloseSalesLogic] Adding batch set for SKU ${item.sku} to quantity ${item.cantidad} in main inventory.`);
                    batch.set(db.collection('inventory').doc(item.sku), item);
                });
                // Filter out any items that might have been reduced to 0 quantity if they were not originally in inventory
                inventory = updatedMainInventory.filter(item => item.cantidad > 0); // Update local state
                console.log('[handleCloseSalesLogic] Local main inventory updated to:', JSON.stringify(inventory.map(i => ({sku: i.sku, cantidad: i.cantidad}))));

                // NEW: Add historical consolidated general sales to batch
                for (const date in salesByDate) {
                    const salesForThisDate = salesByDate[date];
                    const aggregatedSalesBySku = {};
                    let totalOverallSale = 0;
                    salesForThisDate.forEach(sale => {
                        sale.items.forEach(item => {
                            const { sku, producto, presentacion, cantidadVendida, precioUnitario, subtotal } = item;
                            if (!aggregatedSalesBySku[sku]) {
                                aggregatedSalesBySku[sku] = { producto, presentacion, totalCantidad: 0, totalSubtotal: 0 };
                            }
                            aggregatedSalesBySku[sku].totalCantidad += cantidadVendida;
                            aggregatedSalesBySku[sku].totalSubtotal += subtotal;
                            totalOverallSale += subtotal;
                        });
                    });

                    const itemsSoldSummary = [];
                    for (const sku in aggregatedSalesBySku) {
                        const item = aggregatedSalesBySku[sku];
                        itemsSoldSummary.push({
                            sku: sku,
                            producto: item.producto,
                            presentacion: item.presentacion,
                            totalCantidad: item.totalCantidad,
                            totalSubtotal: item.totalSubtotal
                        });
                    }

                    const combinedCSVContent = `Venta General Consolidada - Fecha: ${date}\nVendedor: ${selectedVendor}\n\nSKU,Producto,Presentacion,Cantidad Total,Subtotal Total\n` +
                                               Object.keys(aggregatedSalesBySku).map(sku => {
                                                   const item = aggregatedSalesBySku[sku];
                                                   return `${sku},${item.producto},${item.presentacion},${item.totalCantidad},${item.totalSubtotal.toFixed(2)}`;
                                               }).join('\n') +
                                               `\nTotal General:, , , ,${totalOverallSale.toFixed(2)}`;

                    const generalSaleDocRef = db.collection('historicalConsolidatedGeneralSales').doc(); // Firestore auto-ID
                    batch.set(generalSaleDocRef, {
                        date: date,
                        vendor: selectedVendor,
                        totalOverallSale: totalOverallSale,
                        itemsSoldSummary: itemsSoldSummary,
                        rawCSV: combinedCSVContent,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });

                    // NEW: Add historical consolidated client sales to batch
                    const uniqueSKUs = new Set();
                    const clientSalesData = {};
                    salesForThisDate.forEach(sale => {
                        if (!clientSalesData[sale.client.id]) {
                            clientSalesData[sale.client.id] = { clientName: sale.client.nombreComercial, total: 0, skus: {} };
                        }
                        sale.items.forEach(item => {
                            uniqueSKUs.add(item.sku);
                            clientSalesData[sale.client.id].skus[item.sku] = (clientSalesData[sale.client.id].skus[item.sku] || 0) + item.cantidadVendida;
                            clientSalesData[sale.client.id].total += item.subtotal;
                        });
                    });

                    const sortedUniqueSKUs = Array.from(uniqueSKUs).sort();
                    let clientCSVContent = `Venta General por Clientes - Fecha: ${date}\nVendedor: ${selectedVendor}\n\nCliente,${sortedUniqueSKUs.map(sku => `SKU(${sku})`).join(',')},Total\n`;
                    let grandTotalClients = 0;
                    const clientSalesDetails = [];

                    for (const clientId in clientSalesData) {
                        const clientData = clientSalesData[clientId];
                        let clientRow = `"${clientData.clientName}"`;
                        sortedUniqueSKUs.forEach(sku => { clientRow += `,${clientData.skus[sku] || 0}`; });
                        clientRow += `,${clientData.total.toFixed(2)}\n`;
                        clientCSVContent += clientRow;
                        grandTotalClients += clientData.total;

                        clientSalesDetails.push({
                            clientId: clientId,
                            clientName: clientData.clientName,
                            total: clientData.total,
                            skusSold: clientData.skus
                        });
                    }
                    clientCSVContent += `Total General:,${','.repeat(sortedUniqueSKUs.length)},${grandTotalClients.toFixed(2)}`;


                    const clientSaleDocRef = db.collection('historicalConsolidatedClientSales').doc(); // Firestore auto-ID
                    batch.set(clientSaleDocRef, {
                        date: date,
                        vendor: selectedVendor,
                        grandTotalClients: grandTotalClients,
                        clientSalesDetails: clientSalesDetails,
                        rawCSV: clientCSVContent,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }

                // Update truck inventories based on aggregated sales
                for (const truckPlate in truckSalesAggregates) {
                    const truckSpecificSales = truckSalesAggregates[truckPlate];
                    const truckInventoryDocRef = db.collection('truck_inventories').doc(truckPlate);
                    const truckInventoryDoc = await truckInventoryDocRef.get(); // Fetch current state from Firestore
                    let currentTruckItems = truckInventoryDoc.exists ? (truckInventoryDoc.data().items || []) : [];

                    console.log(`[handleCloseSalesLogic] Processing sales for truck: ${truckPlate}. Initial inventory:`, JSON.stringify(currentTruckItems));

                    for (const sku in truckSpecificSales) {
                        const quantitySoldFromTruck = truckSpecificSales[sku];
                        const itemIndex = currentTruckItems.findIndex(item => item.sku === sku);
                        if (itemIndex !== -1) {
                            console.log(`[handleCloseSalesLogic] Deducting ${quantitySoldFromTruck} of SKU ${sku} from truck ${truckPlate}. Before: ${currentTruckItems[itemIndex].quantity}`);
                            currentTruckItems[itemIndex].quantity = Math.max(0, currentTruckItems[itemIndex].quantity - quantitySoldFromTruck);
                            console.log(`[handleCloseSalesLogic] After deduction: ${currentTruckItems[itemIndex].quantity}`);
                        } else {
                            messages.push(`Advertencia: SKU ${sku} vendido desde el camión ${truckPlate} no encontrado en su inventario durante el cierre.`);
                            console.warn(`[handleCloseSalesLogic] SKU ${sku} sold from truck ${truckPlate} not found in its inventory during closure.`);
                        }
                    }
                    // Filter out items with 0 quantity before saving
                    batch.set(truckInventoryDocRef, { items: currentTruckItems.filter(item => item.quantity > 0) });
                    console.log(`[handleCloseSalesLogic] Added batch set for truck ${truckPlate} inventory:`, JSON.stringify(currentTruckItems.filter(item => item.quantity > 0)));
                }


                allProcessedSaleDocIds.forEach(docId => {
                    console.log(`[handleCloseSalesLogic] Adding batch delete for daily sale DOC ID ${docId}.`);
                    batch.delete(db.collection('dailySales').doc(docId));
                });
                dailySales = dailySales.filter(sale => !allProcessedSaleDocIds.includes(sale.docId)); // Update local state
                console.log('[handleCloseSalesLogic] Local daily sales updated. Remaining sales:', dailySales.length);

                await batch.commit();
                console.log('[handleCloseSalesLogic] Firestore batch commit successful.');
                messages.push('Inventario Principal Actualizado: Las ventas han sido deducidas del inventario principal.');
                messages.push('Inventarios de Camiones Actualizados: Los inventarios de los camiones afectados han sido actualizados.');
                messages.push('Archivos Borrados: Los archivos de ventas individuales procesados han sido "borrados" de Firestore.');
            } catch (error) {
                console.error('[handleCloseSalesLogic] Error during Firestore batch commit:', error);
                messages.push('Error al procesar el cierre de ventas. Por favor, revisa tu conexión y las reglas de seguridad.');
            }
            setScreenAndRender('main');
            showMessageModal(messages.join('\n'));
        };

        const generateThermalReceiptHtml = (saleRecord) => {
            let itemsHtml = saleRecord.items.map(item => `
                <div class="item-row">
                    <span class="item-qty">${item.cantidadVendida}x</span>
                    <span class="item-desc">${item.producto} (${item.presentacion})</span>
                    <span class="item-price">$${item.precioUnitario.toFixed(2)}</span>
                    <span class="item-total">$${item.subtotal.toFixed(2)}</span>
                </div>
            `).join('');

            let modificationReasonHtml = saleRecord.modificationReason ? `
                <div style="border-top: 1px dashed #000; margin: 5px 0;"></div>
                <p style="font-weight: bold;">Motivo Modificación:</p>
                <p>${saleRecord.modificationReason}</p>
            ` : '';

            return `
                <div style="font-family: 'monospace', 'Courier New', Courier, monospace; font-size: 0.75rem; width: 250px; margin: 0 auto; padding: 10px; border: 1px dashed #ccc; background-color: #fff; color: #000; text-align: left; box-shadow: 0 0 5px rgba(0,0,0,0.1);">
                    <h3 style="text-align: center; margin-bottom: 5px; font-size: 0.85rem;">Dist Castillo Ventas</h3>
                    <h4 style="text-align: center; margin-bottom: 5px; font-size: 0.85rem;">Recibo de Venta</h4>
                    <div style="border-top: 1px dashed #000; margin: 5px 0;"></div>
                    <p>Fecha: ${saleRecord.date}</p>
                    <p>Cliente: ${saleRecord.client.nombreComercial}</p>
                    <p>Vendedor: ${saleRecord.vendor || selectedVendor}</p>
                    <div style="border-top: 1px dashed #000; margin: 5px 0;"></div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 2px;">
                        <span style="width: 20%; text-align: left;">Cant.</span>
                        <span style="width: 50%; text-align: left;">Producto</span>
                        <span style="width: 30%; text-align: right;">Total</span>
                    </div>
                    <div style="border-top: 1px dashed #000; margin: 5px 0;"></div>
                    ${itemsHtml}
                    <div style="border-top: 1px dashed #000; margin: 5px 0;"></div>
                    <div style="display: flex; justify-content: space-between; font-weight: bold; margin-top: 5px; font-size: 0.9rem;">
                        <span>TOTAL:</span>
                        <span>$${saleRecord.total.toFixed(2)}</span>
                    </div>
                    ${modificationReasonHtml}
                    <div style="border-top: 1px dashed #000; margin: 5px 0;"></div>
                    <p style="text-align: center; margin-top: 10px; font-size: 0.7rem;">¡Gracias por tu compra!</p>
                </div>
            `;
        };

        const printSaleReceipt = async (saleRecord) => {
            showMessageModal('Generando imagen del recibo...');
            const receiptHtml = generateThermalReceiptHtml(saleRecord);

            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            tempDiv.style.width = '250px';
            tempDiv.innerHTML = receiptHtml;
            document.body.appendChild(tempDiv);

            try {
                const canvas = await html2canvas(tempDiv, { scale: 2, logging: false, useCORS: true });
                const imageDataUrl = canvas.toDataURL('image/png');

                if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([], 'recibo.png', { type: 'image/png' })] })) {
                    const response = await fetch(imageDataUrl);
                    const blob = await response.blob();
                    const file = new File([blob], `recibo_venta_${saleRecord.client.nombreComercial.replace(/\s/g, '_')}_${saleRecord.date}.png`, { type: 'image/png' });
                    await navigator.share({
                        files: [file],
                        title: `Recibo de Venta ${saleRecord.fileName}`,
                        text: `Aquí tienes el recibo de venta para ${saleRecord.client.nombreComercial} del ${saleRecord.date}. Total: $${saleRecord.total.toFixed(2)}`,
                    });
                    showMessageModal('Recibo compartido exitosamente a través de las opciones de tu dispositivo.');
                } else {
                    showMessageModal('La función de compartir avanzada no está disponible en este navegador. Se descargará la imagen del recibo.');
                    const link = document.createElement('a');
                    link.download = `recibo_venta_${saleRecord.client.nombreComercial.replace(/\s/g, '_')}_${saleRecord.date}.png`;
                    link.href = imageDataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    showMessageModal('La imagen del recibo ha sido descargada.');
                }
            } catch (error) {
                console.error('[printSaleReceipt] Error al generar o compartir la imagen:', error);
                showMessageModal('Error al generar o compartir la imagen del recibo. Intenta de nuevo.');
            } finally {
                if (tempDiv && tempDiv.parentNode) {
                    document.body.removeChild(tempDiv);
                }
            }
        };

        const renderArchivosAdminScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden acceder a esta sección.'); setScreenAndRender('main'); return; }
            appRoot.innerHTML = createScreenContainer('ARCHIVOS ADMIN', `
                <p class="text-base text-center my-5 text-gray-600">Esta sección permite cargar y descargar archivos de datos maestros.</p>
                <div class="mb-8 p-4 bg-sky-50 rounded-lg border border-sky-300">
                    <h3 class="text-xl font-bold mb-4 text-sky-700">Cargar Archivos CSV</h3>
                    <div class="mb-3"><label class="block text-gray-700 text-sm font-bold mb-2">Cargar clientes.csv:</label><div class="file-input-wrapper"><button class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-md w-full">Seleccionar archivo</button><input type="file" id="uploadClientsCsv" accept=".csv" onchange="handleFileUpload(event, 'clients')"></div></div>
                    <div class="mb-3"><label class="block text-gray-700 text-sm font-bold mb-2">Cargar inventario.csv (Almacén Principal):</label><div class="file-input-wrapper"><button class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-md w-full">Seleccionar archivo</button><input type="file" id="uploadInventoryCsv" accept=".csv" onchange="handleFileUpload(event, 'inventory')"></div></div>
                    <div class="mb-3"><label class="block text-gray-700 text-sm font-bold mb-2">Cargar vendedor.csv:</label><div class="file-input-wrapper"><button class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-md w-full">Seleccionar archivo</button><input type="file" id="uploadVendorsCsv" accept=".csv" onchange="handleFileUpload(event, 'vendors')"></div></div>
                    <div class="mb-3"><label class="block text-gray-700 text-sm font-bold mb-2">Cargar vehículos.csv:</label><div class="file-input-wrapper"><button class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-md w-full">Seleccionar archivo</button><input type="file" id="uploadVehiclesCsv" accept=".csv" onchange="handleFileUpload(event, 'vehicles')"></div></div>
                </div>
                <div class="mb-8 p-4 bg-emerald-50 rounded-lg border border-emerald-300">
                    <h3 class="text-xl font-bold mb-4 text-emerald-700">Descargar Archivos de Datos</h3>
                    <button class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-md w-full mb-2" onclick="downloadExistingCSV('clientes.csv')">Descargar clientes.csv</button>
                    <button class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-md w-full mb-2" onclick="downloadExistingCSV('inventario.csv')">Descargar inventario.csv (Almacén Principal)</button>
                    <button class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-md w-full mb-2" onclick="downloadExistingCSV('vendedor.csv')">Descargar vendedor.csv</button>
                    <button class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-4 rounded-md w-full mb-2" onclick="downloadExistingCSV('vehiculos.csv')">Descargar vehículos.csv</button>
                </div>
                ${createButton('Volver', "setScreenAndRender('main')", 'bg-gray-600 mt-5 w-full')}
            `);
        };

        const renderArchivosVentaScreen = () => {
            if (!currentUser) { showMessageModal('Acceso denegado: Debes iniciar sesión para ver los archivos de venta.'); setScreenAndRender('login'); return; }
            const saleFilesHtml = dailySales.length === 0 ? '<p class="text-gray-600">No hay archivos de venta generados.</p>' :
                dailySales.map(sale => `
                    <div class="bg-cyan-100 p-3 rounded-lg mb-2 flex flex-wrap justify-between items-center border border-cyan-200">
                        <span class="text-base text-cyan-800 mb-2 sm:mb-0">${sale.fileName}</span>
                        <div class="flex flex-wrap gap-2">
                            <button class="bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-3 rounded-md text-sm transition duration-150 ease-in-out" onclick="printSaleReceipt(${JSON.stringify(sale).replace(/"/g, '&quot;')})">IMPRIMIR</button>
                            ${currentUser ? `<button class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-1 px-3 rounded-md text-sm transition duration-150 ease-in-out" onclick="openModifySaleModal(${JSON.stringify(sale).replace(/"/g, '&quot;')})">MODIFICAR</button>` : ''}
                        </div>
                    </div>
                `).join('');

            appRoot.innerHTML = createScreenContainer('ARCHIVOS DE VENTA', `
                <p class="text-base text-center my-5 text-gray-600">Aquí puedes ver, imprimir y modificar (solo administradores) los archivos de venta generados.</p>
                <div class="p-4 bg-cyan-50 rounded-lg border border-cyan-300">
                    <h3 class="text-xl font-bold mb-4 text-cyan-700">Archivos de Venta Generados</h3>
                    <div id="generated-sale-files-list">${saleFilesHtml}</div>
                </div>
                ${createButton('Volver', "setScreenAndRender('main')", 'bg-gray-600 mt-5 w-full')}
            `);
        };

        const openModifySaleModal = (saleRecord) => {
            selectedSaleForModification = JSON.parse(JSON.stringify(saleRecord));
            modifiedSaleQuantities = {};
            selectedSaleForModification.items.forEach(item => { modifiedSaleQuantities[item.sku] = item.cantidadVendida; });
            modificationReason = selectedSaleForModification.modificationReason || '';
            showModifySaleModalState = true;
            render();
        };

        const closeModifySaleModal = () => {
            showModifySaleModalState = false;
            selectedSaleForModification = null;
            modifiedSaleQuantities = {};
            modificationReason = '';
            render();
        };

        const handleModifiedSaleQuantityChange = (sku, quantity) => {
            modifiedSaleQuantities[sku] = parseInt(quantity) || 0;
        };

        const handleModificationReasonChange = (reason) => {
            modificationReason = reason;
        };

        const renderModifySaleModal = () => {
            if (!showModifySaleModalState || !selectedSaleForModification) return '';

            let productsHtml = '';
            let currentSaleSkus = new Set(selectedSaleForModification.items.map(item => item.sku));
            // The inventory to compare against for current stock should be the source of the original sale
            // Use currentTruckInventory (which is real-time via onSnapshot) or main inventory
            const inventoryToCompare = (selectedSaleForModification.sourceInventory === 'warehouse') ? inventory : currentTruckInventory;

            const renderProductRow = (item, isNew = false) => {
                const productInInventory = inventoryToCompare.find(invItem => invItem.sku === item.sku);
                const currentQuantity = modifiedSaleQuantities[item.sku] !== undefined ? modifiedSaleQuantities[item.sku] : (isNew ? 0 : item.cantidadVendida);
                // Prioritize precioUnitario from sale items, then check price/precio from inventory
                const price = item.precioUnitario !== undefined ? item.precioUnitario : (productInInventory?.price !== undefined ? productInInventory.price : productInInventory?.precio);
                return `
                    <tr>
                        <td><img src="${productImages[item.sku] || productImages['default']}" alt="Imagen de ${item.producto}" class="w-10 h-10 rounded-md object-cover"></td>
                        <td>${item.sku}</td><td>${item.producto}</td><td>${item.presentacion}</td><td>$${price.toFixed(2)}</td>
                        <td><input type="number" class="border border-gray-300 rounded-md text-center w-20" value="${currentQuantity}" onchange="handleModifiedSaleQuantityChange('${item.sku}', this.value)" min="0"></td>
                        <td>${productInInventory ? (productInInventory.quantity || productInInventory.cantidad) : 'N/A'}</td>
                    </tr>
                `;
            };

            productsHtml += selectedSaleForModification.items.map(item => renderProductRow(item)).join('');
            // Add other products from the relevant inventory that were not part of the original sale
            productsHtml += inventoryToCompare.filter(item => !currentSaleSkus.has(item.sku)).map(item => renderProductRow(item, true)).join('');

            return `
                <div id="modify-sale-modal" class="modal">
                    <div class="modal-content">
                        <h3 class="text-2xl font-bold mb-4 text-center text-indigo-700">Modificar Venta</h3>
                        <p class="text-lg font-bold mb-2">Cliente: ${selectedSaleForModification.client.nombreComercial}</p>
                        <p class="text-md text-gray-700 mb-4">Fecha: ${selectedSaleForModification.date}</p>
                        <p class="text-md text-gray-700 mb-4">Origen: ${selectedSaleForModification.sourceInventory === 'warehouse' ? 'Almacén Principal' : `Camión ${selectedSaleForModification.sourceInventory}`}</p>
                        ${createTable(['Imagen', 'SKU', 'Producto', 'Presentación', 'Precio Unitario', 'Cantidad', 'Disp. Actual'], productsHtml, 'modify-sale-products-body')}
                        <div class="mb-4 text-left">
                            <label for="modificationReason" class="block text-gray-700 text-sm font-bold mb-2">Motivo de la Modificación:</label>
                            <textarea id="modificationReason" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline" rows="3" onchange="handleModificationReasonChange(this.value)">${modificationReason}</textarea>
                        </div>
                        <div class="flex justify-around gap-4 mt-5">
                            <button class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-5 rounded-lg flex-1 shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="saveModifiedSale()">Guardar Modificación</button>
                            <button class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-5 rounded-lg flex-1 shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="closeModifySaleModal()">Cancelar</button>
                        </div>
                    </div>
                </div>
            `;
        };

        const saveModifiedSale = async () => {
            if (!modificationReason.trim()) { showMessageModal('Por favor, ingresa un motivo para la modificación.'); return; }

            const oldSaleItemsMap = new Map(selectedSaleForModification.items.map(item => [item.sku, item.cantidadVendida]));
            const newSaleItems = [];
            let newTotalSaleAmount = 0;
            let inventoryUpdates = {};
            let validationErrors = [];

            const sourceInventoryPlate = selectedSaleForModification.sourceInventory;
            let currentInventoryDataForValidation;

            if (sourceInventoryPlate === 'warehouse') {
                currentInventoryDataForValidation = inventory;
            } else {
                // Use the current local truck inventory for validation, as it's real-time
                currentInventoryDataForValidation = JSON.parse(JSON.stringify(currentTruckInventory));
            }

            for (const sku in modifiedSaleQuantities) {
                const newQty = modifiedSaleQuantities[sku];
                const oldQty = oldSaleItemsMap.get(sku) || 0;
                const netChange = newQty - oldQty;

                const productInInventory = currentInventoryDataForValidation.find(invItem => invItem.sku === sku);
                const availableQuantity = productInInventory ? (productInInventory.quantity !== undefined ? productInInventory.quantity : productInInventory.cantidad) : 0;

                // If increasing quantity (netChange > 0), ensure enough stock
                if (netChange > 0 && netChange > availableQuantity + oldQty) { // Corrected validation: available + old_sold should be >= new_sold
                    validationErrors.push(`Error: La cantidad adicional de "${sku}" (${netChange}) excede el stock disponible (${availableQuantity}).`);
                }
                // If decreasing quantity (netChange < 0), no stock check needed.

                if (newQty > 0) {
                    const productDetails = inventory.find(item => item.sku === sku) || currentTruckInventory.find(item => item.sku === sku);
                    if (productDetails) {
                        const price = productDetails.price !== undefined ? productDetails.price : productDetails.precio;
                        newSaleItems.push({ sku: productDetails.sku, producto: productDetails.producto, presentacion: productDetails.presentacion, cantidadVendida: newQty, precioUnitario: price, subtotal: newQty * price });
                        newTotalSaleAmount += newQty * price;
                    }
                }
                if (netChange !== 0) inventoryUpdates[sku] = (inventoryUpdates[sku] || 0) + netChange;
            }

            if (validationErrors.length > 0) {
                showMessageModal(validationErrors.join('\n'));
                return;
            }

            if (newSaleItems.length === 0 && Object.keys(inventoryUpdates).length === 0) {
                showMessageModal('La venta modificada no puede estar vacía y no hay cambios de inventario. Ajusta las cantidades o cancela.'); return;
            }

            selectedSaleForModification.items = newSaleItems;
            selectedSaleForModification.total = newTotalSaleAmount;
            selectedSaleForModification.modificationReason = modificationReason.trim();
            selectedSaleForModification.rawCSV =
                `SKU,Producto,Presentacion,Cantidad,Precio Unitario,Subtotal\n` +
                newSaleItems.map(item => `${item.sku},${item.producto},${item.presentacion},${item.cantidadVendida},${item.precioUnitario.toFixed(2)},${item.subtotal.toFixed(2)}`).join('\n') +
                `\nTotal General:, , , , ,${newTotalSaleAmount.toFixed(2)}\n` +
                `Motivo de Modificación:,${modificationReason.trim()}`;

            // 1. Update local state immediately for UI responsiveness
            dailySales = dailySales.map(sale => sale.docId === selectedSaleForModification.docId ? selectedSaleForModification : sale);

            if (sourceInventoryPlate && sourceInventoryPlate !== 'warehouse') {
                let currentTruckItems = JSON.parse(JSON.stringify(currentTruckInventory)); // Use current local truck inventory
                for (const sku in inventoryUpdates) {
                    const delta = inventoryUpdates[sku]; // This delta is (newQty - oldQty)
                    const itemIndex = currentTruckItems.findIndex(item => item.sku === sku);
                    const productDetails = inventory.find(item => item.sku === sku); // Fallback to main inventory for product details

                    if (itemIndex !== -1) {
                        currentTruckItems[itemIndex].quantity = Math.max(0, currentTruckItems[itemIndex].quantity - delta);
                    } else if (delta > 0 && productDetails) { // If adding a new item to truck inventory
                        currentTruckItems.push({
                            sku: productDetails.sku, rubro: productDetails.rubro, segmento: productDetails.segmento,
                            producto: productDetails.producto, presentacion: productDetails.presentacion,
                            quantity: delta, price: productDetails.precio
                        });
                    }
                }
                currentTruckItems = currentTruckItems.filter(item => item.quantity > 0);
                // Update the global currentTruckInventory. The onSnapshot listener will then reflect this.
                if (currentUserData.assignedTruckPlate === sourceInventoryPlate) currentTruckInventory = currentTruckItems;
            }
            // No main inventory update here.

            // 2. Render UI immediately to reflect changes
            closeModifySaleModal(); // This will re-render and close the modal
            showMessageModal('Venta modificada y guardada localmente. Se sincronizará cuando haya conexión a internet.');

            // 3. Perform Firestore write in background (non-blocking)
            try {
                const batch = db.batch();
                batch.set(db.collection('dailySales').doc(selectedSaleForModification.docId), selectedSaleForModification);

                if (sourceInventoryPlate && sourceInventoryPlate !== 'warehouse') {
                    batch.set(db.collection('truck_inventories').doc(sourceInventoryPlate), { items: currentTruckInventory });
                }
                // No main inventory update here.

                await batch.commit(); // Await the commit for proper error handling
                console.log('Firestore commit successful for modified sale:', selectedSaleForModification.fileName);

                // Re-fetch other data (not truck inventory, as onSnapshot handles it)
                await fetchDataFromFirestore();

            } catch (error) {
                console.error('Error al modificar venta en Firestore (puede ser por falta de conexión):', error);
                if (error.code !== 'unavailable' && error.code !== 'internal' && error.code !== 'failed-precondition') {
                    showMessageModal('Error al guardar la modificación de venta en la nube. Por favor, revisa tu conexión y las reglas de seguridad.');
                }
            }
        };

        const handleFileUpload = async (event, type) => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden cargar archivos CSV.'); return; }
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const parsedData = parseCSV(e.target.result);
                try {
                    const collectionRef = db.collection(type === 'clients' ? 'clients' : type === 'inventory' ? 'inventory' : type === 'vendors' ? 'vendors' : 'vehicles');
                    const existingSnapshot = await collectionRef.get();
                    existingSnapshot.docs.forEach(doc => doc.ref.delete());

                    for (const row of parsedData) {
                        if (type === 'clients') {
                            await collectionRef.doc(row.ID).set({ id: row.ID, nombreComercial: row['Nombre Comercial'], nombrePersonal: row['Nombre Personal'], zona: row.Zona, sector: row.Sector, tlf: row.Tlf, observaciones: row.Observaciones });
                        } else if (type === 'inventory') {
                            await collectionRef.doc(row.Sku).set({ rubro: row.Rubro, sku: row.Sku, segmento: row.Segmento, producto: row.Producto, presentacion: row.Presentacion, cantidad: parseInt(row.Cantidad) || 0, precio: parseFloat(row.Precio) || 0 });
                        } else if (type === 'vendors') {
                            await collectionRef.doc((row['Wilfredo Chacon'] || row.Name).replace(/\s/g, '_')).set({ name: row['Wilfredo Chacon'] || row.Name, category: row['Alimentos'] || row.Category });
                        } else if (type === 'vehicles') {
                            await collectionRef.doc(row.Plate).set({ plate: row.Plate, name: row.Name, brand: row.Brand, model: row.Model });
                            await db.collection('truck_inventories').doc(row.Plate).set({ items: [] });
                        }
                    }
                    await fetchDataFromFirestore();
                    showMessageModal(`${type}.csv cargado y guardado exitosamente en Firestore.`);
                    if (type === 'vendors' && vendors.length > 0 && selectedVendor === 'Ninguno') {
                        selectedVendor = vendors[0].name;
                        localStorage.setItem('selectedVendor', selectedVendor);
                    }
                    render();
                } catch (error) {
                    console.error('Error al cargar archivo CSV a Firestore:', error);
                    showMessageModal('Error al cargar archivo. Por favor, revisa tu conexión y las reglas de seguridad de Firestore.');
                }
            };
            reader.readAsText(file);
        };

        const renderVehiclesScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden gestionar vehículos.'); setScreenAndRender('main'); return; }

            const tableRows = vehicles.map(vehicle => `
                <td>${vehicle.plate}</td><td>${vehicle.name}</td><td>${vehicle.brand || 'N/A'}</td><td>${vehicle.model || 'N/A'}</td>
                <td>
                    <button class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-1 px-2 rounded-md text-sm mr-2" onclick="editVehicle('${vehicle.plate}')">Editar</button>
                    <button class="bg-red-500 hover:bg-red-600 text-white font-bold py-1 px-2 rounded-md text-sm" onclick="showDeleteVehicleConfirmation('${vehicle.plate}')">Eliminar</button>
                </td>
            `).map(row => `<tr>${row}</tr>`).join('');

            appRoot.innerHTML = createScreenContainer('VEHÍCULOS DE CARGA', `
                <div class="mb-8 p-4 bg-emerald-50 rounded-lg border border-emerald-300">
                    <h3 class="text-xl font-bold mb-4 text-emerald-700">Lista de Vehículos</h3>
                    ${createTable(['Placa', 'Nombre', 'Marca', 'Modelo', 'Acciones'], tableRows, 'vehicles-table-body')}
                </div>
                <div class="p-4 bg-lime-50 rounded-lg border border-lime-300">
                    <h3 class="text-xl font-bold mb-4 text-lime-700">${editingVehicle ? 'Editar Vehículo' : 'Agregar Nuevo Vehículo'}</h3>
                    ${createInput('vehiclePlate', 'Placa', editingVehicle?.plate, 'text', !!editingVehicle)}
                    ${createInput('vehicleName', 'Nombre (ej. Volswaguen Worker 220)', editingVehicle?.name)}
                    ${createInput('vehicleBrand', 'Marca', editingVehicle?.brand)}
                    ${createInput('vehicleModel', 'Modelo', editingVehicle?.model)}
                    <button class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-5 rounded-lg mt-3 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="${editingVehicle ? 'saveEditedVehicle()' : 'handleAddVehicle()'}">${editingVehicle ? 'Guardar Cambios' : 'Agregar Vehículo'}</button>
                    ${editingVehicle ? `<button class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-5 rounded-lg mt-3 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="cancelEditVehicle()">Cancelar Edición</button>` : ''}
                </div>
                ${createButton('Volver', "setScreenAndRender('main')", 'bg-gray-600 mt-5 w-full')}
            `);
        };

        const handleAddVehicle = async () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden agregar vehículos.'); return; }
            const plate = document.getElementById('vehiclePlate').value.trim();
            const name = document.getElementById('vehicleName').value.trim();
            const brand = document.getElementById('vehicleBrand').value.trim();
            const model = document.getElementById('vehicleModel').value.trim();

            if (!plate || !name) { showMessageModal('La placa y el nombre del vehículo son obligatorios.'); return; }
            if (vehicles.some(v => v.plate === plate)) { showMessageModal('Ya existe un vehículo con esta placa.'); return; }

            const newVehicle = { plate, name, brand, model };
            try {
                await db.collection('vehicles').doc(plate).set(newVehicle);
                await db.collection('truck_inventories').doc(plate).set({ items: [] });
                vehicles.push(newVehicle);
                showMessageModal('Vehículo agregado exitosamente y su inventario de camión creado.');
                render();
            } catch (error) {
                console.error('Error al agregar vehículo:', error);
                showMessageModal('Error al agregar vehículo. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const editVehicle = (plate) => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden editar vehículos.'); return; }
            editingVehicle = vehicles.find(v => v.plate === plate);
            render();
        };

        const cancelEditVehicle = () => {
            editingVehicle = null;
            render();
        };

        const saveEditedVehicle = async () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden guardar cambios en vehículos.'); return; }
            if (!editingVehicle) return;

            const name = document.getElementById('vehicleName').value.trim();
            const brand = document.getElementById('vehicleBrand').value.trim();
            const model = document.getElementById('vehicleModel').value.trim();

            if (!name) { showMessageModal('El nombre del vehículo es obligatorio.'); return; }

            const updatedVehicle = { ...editingVehicle, name, brand, model };
            try {
                await db.collection('vehicles').doc(updatedVehicle.plate).set(updatedVehicle);
                vehicles = vehicles.map(v => v.plate === updatedVehicle.plate ? updatedVehicle : v);
                showMessageModal('Vehículo actualizado exitosamente.');
                editingVehicle = null;
                render();
            } catch (error) {
                console.error('Error al actualizar vehículo:', error);
                showMessageModal('Error al actualizar vehículo. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const showDeleteVehicleConfirmation = (plate) => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden eliminar vehículos.'); return; }
            showConfirmationModal(`¿Estás seguro de que quieres eliminar el vehículo con placa ${plate}? Esto también eliminará su inventario de camión.`, () => deleteVehicle(plate));
        };

        const deleteVehicle = async (plate) => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden eliminar vehículos.'); return; }
            try {
                await db.collection('vehicles').doc(plate).delete();
                await db.collection('truck_inventories').doc(plate).delete();
                vehicles = vehicles.filter(v => v.plate !== plate);
                showMessageModal('Vehículo y su inventario de camión eliminados exitosamente.');
                render();
            } catch (error) {
                console.error('Error al eliminar vehículo:', error);
                showMessageModal('Error al eliminar vehículo. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const renderAssignVehicleScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden asignar vehículos.'); setScreenAndRender('main'); return; }

            const vehicleOptions = vehicles.map(v => ({ value: v.plate, text: `${v.name} (${v.plate})` }));
            const tableRows = users.map(user => `
                <td>${user.email}</td><td>${user.role}</td><td>${user.assignedTruckPlate || 'Ninguno'}</td>
                <td>${createSelect(`assignTruck-${user.uid}`, vehicleOptions, user.assignedTruckPlate, `handleAssignVehicle('${user.uid}')`, '-- No asignar --')}</td>
                <td><button class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-1 px-3 rounded-md text-sm" onclick="handleAssignVehicle('${user.uid}')">Guardar</button></td>
            `).map(row => `<tr>${row}</tr>`).join('');

            appRoot.innerHTML = createScreenContainer('ASIGNAR VEHÍCULO A VENDEDOR', `
                <div class="mb-8 p-4 bg-blue-50 rounded-lg border border-blue-300">
                    <h3 class="text-xl font-bold mb-4 text-blue-700">Asignar Camión a Usuarios</h3>
                    ${createTable(['Correo Electrónico', 'Rol', 'Camión Asignado', 'Asignar Nuevo Camión', 'Acciones'], tableRows, 'user-assignment-table-body')}
                </div>
                ${createButton('Volver', "setScreenAndRender('main')", 'bg-gray-600 mt-5 w-full')}
            `);
        };

        const handleAssignVehicle = async (userId) => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden asignar vehículos.'); return; }
            const selectElement = document.getElementById(`assignTruck-${userId}`);
            const newAssignedTruckPlate = selectElement.value || null;

            try {
                await db.collection('users').doc(userId).update({ assignedTruckPlate: newAssignedTruckPlate });
                users = users.map(u => u.uid === userId ? { ...u, assignedTruckPlate: newAssignedTruckPlate } : u);
                if (currentUser && currentUser.uid === userId) {
                    currentUserData.assignedTruckPlate = newAssignedTruckPlate;
                    setupTruckInventoryListener(); // Re-setup listener if current user's truck changed
                }
                showMessageModal(`Vehículo asignado exitosamente al usuario ${users.find(u => u.uid === userId).email}.`);
                render();
            } catch (error) {
                console.error('Error al asignar vehículo:', error);
                showMessageModal('Error al asignar vehículo. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const renderLoadHistoryScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden ver el historial de cargas.'); setScreenAndRender('main'); return; }

            const sortedLoadRecords = [...loadRecords].sort((a, b) => {
                // Assuming date is in DDMMYYYY format for sorting
                const dateA = parseInt(a.date.substring(4, 8) + a.date.substring(2, 4) + a.date.substring(0, 2));
                const dateB = parseInt(b.date.substring(4, 8) + b.date.substring(2, 4) + b.date.substring(0, 2));
                return dateB - dateA; // Sort descending by date
            });

            const loadFilesHtml = sortedLoadRecords.length === 0 ? '<p class="text-gray-600">No hay archivos de carga generados.</p>' :
                sortedLoadRecords.map(record => `
                    <div class="bg-yellow-100 p-3 rounded-lg mb-2 flex flex-wrap justify-between items-center border border-yellow-200">
                        <span class="text-base text-yellow-800 mb-2 sm:mb-0">
                            ${record.fileName} <br>
                            <span class="text-sm text-gray-600">Camión: ${record.truckName} (${record.truckPlate}) - Cargador: ${record.loader} - Total: $${record.total.toFixed(2)}</span>
                        </span>
                        <div class="flex flex-wrap gap-2">
                            <button class="bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-3 rounded-md text-sm transition duration-150 ease-in-out" onclick="downloadExistingCSV('${record.fileName}')">DESCARGAR CSV</button>
                        </div>
                    </div>
                `).join('');

            appRoot.innerHTML = createScreenContainer('HISTORIAL DE CARGAS', `
                <p class="text-base text-center my-5 text-gray-600">Aquí puedes ver y descargar los archivos de cargas generados.</p>
                <div class="p-4 bg-yellow-50 rounded-lg border border-yellow-300">
                    <h3 class="text-xl font-bold mb-4 text-yellow-700">Archivos de Carga Generados</h3>
                    <div id="generated-load-files-list">${loadFilesHtml}</div>
                </div>
                <button class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-5 rounded-lg mt-5 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="showClearLoadHistoryConfirmation()">Limpiar Historial</button>
                ${createButton('Volver', "setScreenAndRender('cargaSelection')", 'bg-gray-600 mt-3 w-full')}
            `);
        };

        const showClearLoadHistoryConfirmation = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden limpiar el historial de cargas.'); return; }
            showConfirmationModal('Confirma desea borrar el Historial de Cargas', clearLoadHistoryLogic);
        };

        const clearLoadHistoryLogic = async () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden limpiar el historial de cargas.'); return; }
            try {
                const batch = db.batch();
                const loadRecordsSnapshot = await db.collection('loadRecords').get();
                loadRecordsSnapshot.docs.forEach(doc => batch.delete(doc.ref));
                await batch.commit();
                loadRecords = [];
                showMessageModal('Historial de cargas borrado exitosamente.');
                render();
            } catch (error) {
                console.error('Error al limpiar el historial de cargas:', error);
                showMessageModal('Error al limpiar el historial de cargas. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const renderTransferInventoryPasswordScreen = () => {
            if (!isUser() || !currentUserData.assignedTruckPlate) {
                showMessageModal('Acceso denegado o no tienes un camión asignado.'); setScreenAndRender('main'); return;
            }
            appRoot.innerHTML = createScreenContainer('Confirmación de Seguridad', `
                <p class="text-lg text-center mb-6 text-gray-700">Ingrese contraseña para confirmar la operación de transbordo.</p>
                ${createInput('userPasswordForTransfer', 'Contraseña', '', 'password')}
                <button class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-5 rounded-lg w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="handleTransferInventoryPassword()">Continuar</button>
                <button class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-5 rounded-lg mt-3 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="setScreenAndRender('main')">Cancelar</button>
            `, 'max-w-md mx-auto my-10');
        };

        const handleTransferInventoryPassword = async () => {
            const password = document.getElementById('userPasswordForTransfer').value;
            if (!password) { showMessageModal('Por favor, ingresa tu contraseña.'); return; }
            try {
                await firebase.auth.EmailAuthProvider.credential(currentUser.email, password);
                selectedDestinationTruck = null;
                transferQuantities = {};
                setScreenAndRender('transferInventory');
            } catch (error) {
                showMessageModal(`Error de autenticación: ${error.message}. Contraseña incorrecta o sesión expirada.`);
            }
        };

        const renderTransferInventoryScreen = () => {
            if (!isUser() || !currentUserData.assignedTruckPlate) { showMessageModal('Acceso denegado o no tienes un camión asignado.'); setScreenAndRender('main'); return; }
            const sourceTruck = vehicles.find(v => v.plate === currentUserData.assignedTruckPlate);
            if (!sourceTruck) { showMessageModal('No se encontró información para tu camión asignado.'); setScreenAndRender('main'); return; }

            const destinationTrucks = vehicles.filter(v => v.plate !== sourceTruck.plate);
            const destinationOptions = destinationTrucks.map(v => ({ value: v.plate, text: `${v.name} (${v.plate})` }));

            let productsTableHtml = '';
            if (selectedDestinationTruck) {
                const tableRows = currentTruckInventory.map(item => {
                    if (transferQuantities[item.sku] === undefined) transferQuantities[item.sku] = 0;
                    return `
                        <td><img src="${productImages[item.sku] || productImages['default']}" alt="Imagen de ${item.producto}" class="w-12 h-12 rounded-md object-cover"></td>
                        <td>${item.sku}</td><td>${item.producto}</td><td>${item.presentacion}</td><td>${item.quantity}</td>
                        <td><input type="number" class="border border-gray-300 rounded-md text-center w-20" value="${transferQuantities[item.sku]}" onchange="handleTransferQuantityChange('${item.sku}', this.value)" min="0" max="${item.quantity}"></td>
                    `;
                }).map(row => `<tr>${row}</tr>`).join('');

                productsTableHtml = `
                    <p class="text-base text-center mb-4 text-gray-700">Cantidad a trasladar del camión <strong>${sourceTruck.name}</strong> al camión <strong>${selectedDestinationTruck.name}</strong>.</p>
                    ${createTable(['Imagen', 'SKU', 'Producto', 'Presentación', 'Disponible', 'Cantidad a Trasladar'], tableRows, 'products-for-transfer-body')}
                    <button class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-3 px-5 rounded-lg mt-5 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="showTransferConfirmation()">Realizar Transbordo</button>
                `;
            } else {
                productsTableHtml = '<p class="text-center text-gray-600">Por favor, seleccione un camión de destino para continuar.</p>';
            }

            appRoot.innerHTML = createScreenContainer('TRANSBORDO DE INVENTARIO', `
                <p class="text-lg text-center mb-4 text-gray-700">Camión de Origen: <strong>${sourceTruck.name} (${sourceTruck.plate})</strong></p>
                <div class="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-300">
                    <label for="destinationTruckSelect" class="block text-lg font-semibold text-blue-700 mb-2">Seleccionar Camión de Destino:</label>
                    ${createSelect('destinationTruckSelect', destinationOptions, selectedDestinationTruck?.plate, 'handleDestinationTruckSelection(this.value)')}
                </div>
                ${productsTableHtml}
                <div class="p-4 bg-yellow-50 rounded-lg border border-yellow-300 mt-8">
                    <h3 class="text-xl font-bold mb-4 text-yellow-700">Historial de Traslados</h3>
                    <div id="user-transfer-history-list"></div>
                </div>
                ${createButton('Volver', "setScreenAndRender('main')", 'bg-gray-600 mt-5 w-full')}
            `);
            updateUserTransferHistoryDisplay();
        };

        const handleDestinationTruckSelection = (plate) => {
            selectedDestinationTruck = plate ? vehicles.find(v => v.plate === plate) : null;
            transferQuantities = {};
            render();
        };

        const handleTransferQuantityChange = (sku, quantity) => {
            transferQuantities[sku] = parseInt(quantity) || 0;
        };

        const showTransferConfirmation = () => {
            showConfirmationModal('¿Estás seguro de que quieres realizar este transbordo de inventario? Esto modificará los inventarios de ambos camiones.', performInventoryTransfer);
        };

        const performInventoryTransfer = async () => {
            if (!isUser() || !currentUserData.assignedTruckPlate || !selectedDestinationTruck) {
                showMessageModal('Error: No se puede realizar el transbordo. Asegúrate de tener un camión asignado y un camión de destino seleccionado.'); return;
            }

            const sourceTruckPlate = currentUserData.assignedTruckPlate;
            const destinationTruckPlate = selectedDestinationTruck.plate;

            let transferData = [];
            let messages = [];
            let hasPositiveTransferQuantity = false;

            // Use the current local state for source truck inventory
            let sourceTruckInventoryCopy = JSON.parse(JSON.stringify(currentTruckInventory));
            let destinationTruckInventoryCopy = [];
            try {
                // Fetch destination truck inventory from Firestore (it might be managed by another user/admin)
                const destTruckDoc = await db.collection('truck_inventories').doc(destinationTruckPlate).get();
                destinationTruckInventoryCopy = destTruckDoc.exists ? (destTruckDoc.data().items || []) : [];
            } catch (error) {
                console.error('Error al cargar inventario del camión de destino:', error);
                showMessageModal('Error al cargar el inventario del camión de destino. Intenta de nuevo.'); return;
            }

            for (const sku in transferQuantities) {
                const quantityToTransfer = transferQuantities[sku];
                if (quantityToTransfer <= 0) continue;
                hasPositiveTransferQuantity = true;

                const sourceItemIndex = sourceTruckInventoryCopy.findIndex(item => item.sku === sku);
                const sourceItem = sourceItemIndex !== -1 ? sourceTruckInventoryCopy[sourceItemIndex] : null;

                if (!sourceItem || quantityToTransfer > sourceItem.quantity) {
                    messages.push(`Error: Cantidad insuficiente para SKU "${sku}" en el camión de origen. Disponible: ${sourceItem ? sourceItem.quantity : 0}, Intentado trasladar: ${quantityToTransfer}.`);
                    continue;
                }

                sourceTruckInventoryCopy[sourceItemIndex].quantity -= quantityToTransfer;

                const destItemIndex = destinationTruckInventoryCopy.findIndex(item => item.sku === sku);
                if (destItemIndex !== -1) {
                    destinationTruckInventoryCopy[destItemIndex].quantity += quantityToTransfer;
                } else {
                    const productDetails = inventory.find(item => item.sku === sku);
                    if (productDetails) {
                        destinationTruckInventoryCopy.push({
                            sku: productDetails.sku, rubro: productDetails.rubro, segmento: productDetails.segmento,
                            producto: productDetails.producto, presentacion: productDetails.presentacion,
                            quantity: quantityToTransfer, price: productDetails.precio
                        });
                    } else {
                        messages.push(`Advertencia: Producto con SKU ${sku} no encontrado en el inventario principal. No se pudo añadir completamente al camión de destino.`);
                    }
                }
                transferData.push({
                    sku: sku, producto: sourceItem.producto, presentacion: sourceItem.presentacion,
                    cantidadTrasladada: quantityToTransfer, camionOrigen: sourceTruckPlate, camionDestino: destinationTruckPlate
                });
            }

            if (messages.length > 0) { showMessageModal(messages.join('\n')); return; }
            if (!hasPositiveTransferQuantity) { showMessageModal('Por favor, ingresa al menos una cantidad positiva para realizar el transbordo.'); return; }

            const transferFileName = `traslado_${sourceTruckPlate}_${destinationTruckPlate}_${getCurrentDateFormatted()}.csv`;
            const transferCSVContent = `SKU,Producto,Presentacion,Cantidad Trasladada,Camion Origen,Camion Destino\n` +
                                       transferData.map(item => `${item.sku},${item.producto},${item.presentacion},${item.cantidadTrasladada},${item.camionOrigen},${item.camionDestino}`).join('\n');

            const transferRecord = {
                fileName: transferFileName, date: getCurrentDateFormatted(), sourceTruckPlate: sourceTruckPlate,
                destinationTruckPlate: destinationTruckPlate, userId: currentUser.uid, items: transferData, rawCSV: transferCSVContent
            };

            try {
                const batch = db.batch();
                batch.set(db.collection('truck_inventories').doc(sourceTruckPlate), { items: sourceTruckInventoryCopy.filter(item => item.quantity > 0) });
                batch.set(db.collection('truck_inventories').doc(destinationTruckPlate), { items: destinationTruckInventoryCopy.filter(item => item.quantity > 0) });
                const docRef = await db.collection('transferRecords').add(transferRecord);
                transferRecord.docId = docRef.id;
                await batch.commit();

                // Update local currentTruckInventory, which will be reflected by onSnapshot
                currentTruckInventory = sourceTruckInventoryCopy;
                transferRecords.push(transferRecord); // Add to local list

                showMessageModal('Transbordo de inventario realizado exitosamente. Archivo generado.');
                triggerCSVDownload(transferFileName, transferCSVContent); // Usar la nueva función para descargar
                selectedDestinationTruck = null;
                transferQuantities = {};
                render();
            } catch (error) {
                console.error('Error al realizar transbordo de inventario:', error);
                showMessageModal('Error al realizar transbordo. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const updateUserTransferHistoryDisplay = () => {
            const userTransferHistoryListDiv = document.getElementById('user-transfer-history-list');
            if (!userTransferHistoryListDiv) return;

            const userSpecificTransferRecords = transferRecords.filter(record => record.userId === currentUser.uid);
            const sortedUserTransferRecords = [...userSpecificTransferRecords].sort((a, b) => {
                const dateA = parseInt(a.date.substring(4, 8) + a.date.substring(2, 4) + a.date.substring(0, 2));
                const dateB = parseInt(b.date.substring(4, 8) + b.date.substring(2, 4) + b.date.substring(0, 2));
                return dateB - dateA;
            });

            if (sortedUserTransferRecords.length === 0) {
                userTransferHistoryListDiv.innerHTML = '<p class="text-gray-600">No hay traslados registrados para tu usuario.</p>';
            } else {
                userTransferHistoryListDiv.innerHTML = sortedUserTransferRecords.map(record => {
                    const userEmail = users.find(u => u.uid === record.userId)?.email || 'Desconocido';
                    return `
                        <div class="bg-yellow-100 p-3 rounded-lg mb-2 flex flex-wrap justify-between items-center border border-yellow-200">
                            <span class="text-base text-yellow-800 mb-2 sm:mb-0">
                                ${record.fileName} <br>
                                <span class="text-sm text-gray-600">Origen: ${record.sourceTruckPlate} - Destino: ${record.destinationTruckPlate} - Realizado por: ${userEmail} - Fecha: ${record.date}</span>
                            </span>
                            <div class="flex flex-wrap gap-2">
                                <button class="bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-3 rounded-md text-sm transition duration-150 ease-in-out" onclick="downloadExistingCSV('${record.fileName}')">DESCARGAR CSV</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
        };

        const renderAdminTransferHistoryScreen = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden ver el historial de transbordos.'); setScreenAndRender('main'); return; }

            const sortedTransferRecords = [...transferRecords].sort((a, b) => {
                const dateA = parseInt(a.date.substring(4, 8) + a.date.substring(2, 4) + a.date.substring(0, 2));
                const dateB = parseInt(b.date.substring(4, 8) + b.date.substring(2, 4) + b.date.substring(0, 2));
                return dateB - dateA;
            });

            const transferFilesHtml = sortedTransferRecords.length === 0 ? '<p class="text-gray-600">No hay archivos de transbordo generados.</p>' :
                sortedTransferRecords.map(record => {
                    const userEmail = users.find(u => u.uid === record.userId)?.email || 'Desconocido';
                    return `
                        <div class="bg-yellow-100 p-3 rounded-lg mb-2 flex flex-wrap justify-between items-center border border-yellow-200">
                            <span class="text-base text-yellow-800 mb-2 sm:mb-0">
                                ${record.fileName} <br>
                                <span class="text-sm text-gray-600">Origen: ${record.sourceTruckPlate} - Destino: ${record.destinationTruckPlate} - Realizado por: ${userEmail} - Fecha: ${record.date}</span>
                            </span>
                            <div class="flex flex-wrap gap-2">
                                <button class="bg-green-500 hover:bg-green-600 text-white font-bold py-1 px-3 rounded-md text-sm transition duration-150 ease-in-out" onclick="downloadExistingCSV('${record.fileName}')">DESCARGAR CSV</button>
                            </div>
                        </div>
                    `;
                }).join('');

            appRoot.innerHTML = createScreenContainer('HISTORIAL DE TRANSBORDOS', `
                <p class="text-base text-center my-5 text-gray-600">Aquí puedes ver y descargar todos los archivos de transbordo generados.</p>
                <div class="p-4 bg-yellow-50 rounded-lg border border-yellow-300">
                    <h3 class="text-xl font-bold mb-4 text-yellow-700">Archivos de Transbordo Generados</h3>
                    <div id="admin-transfer-history-list">${transferFilesHtml}</div>
                </div>
                <button class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-5 rounded-lg mt-5 w-full shadow-md transition duration-300 ease-in-out transform hover:scale-105" onclick="showClearTransferHistoryConfirmation()">Limpiar Historial de Transbordo</button>
                ${createButton('Volver', "setScreenAndRender('main')", 'bg-gray-600 mt-3 w-full')}
            `);
        };

        const showClearTransferHistoryConfirmation = () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden limpiar el historial de transbordos.'); return; }
            showConfirmationModal('Confirma desea borrar el Historial de Transbordos (esto afectará a todos los usuarios).', clearTransferHistoryLogic);
        };

        const clearTransferHistoryLogic = async () => {
            if (!isAdmin()) { showMessageModal('Acceso denegado: Solo los administradores pueden limpiar el historial de transbordos.'); return; }
            try {
                const batch = db.batch();
                const transferRecordsSnapshot = await db.collection('transferRecords').get();
                transferRecordsSnapshot.docs.forEach(doc => batch.delete(doc.ref));
                await batch.commit();
                transferRecords = [];
                showMessageModal('Historial de transbordos borrado exitosamente.');
                render();
            } catch (error) {
                console.error('Error al limpiar el historial de transbordos:', error);
                showMessageModal('Error al limpiar el historial de transbordos. Revisa tu conexión y reglas de seguridad.');
            }
        };

        const setScreenAndRender = (newScreen) => {
            console.log(`[setScreenAndRender] Changing screen to: ${newScreen}`);
            // Clean up admin truck inventory listener if navigating away from admin inventory screens
            if (adminTruckInventoryUnsubscribe && newScreen !== 'adminVehicleInventory') {
                adminTruckInventoryUnsubscribe();
                adminTruckInventoryUnsubscribe = null;
                console.log('[Firestore Listener] Unsubscribed from admin truck inventory listener due to screen change.');
            }
            screen = newScreen;
            render();
        };

        if ('serviceWorker' in navigator) {
            document.addEventListener('DOMContentLoaded', () => {
                const serviceWorkerFileName = 'service-worker.js';
                const baseUrl = window.location.pathname.endsWith('/') ? window.location.pathname : window.location.pathname + '/';
                const absoluteServiceWorkerUrl = baseUrl + serviceWorkerFileName;

                navigator.serviceWorker.register(absoluteServiceWorkerUrl)
                    .then(registration => console.log('[Service Worker] Service Worker registrado con éxito:', registration))
                    .catch(error => console.error('[Service Worker] Fallo el registro del Service Worker:', error));
            });
        }

        window.onload = () => {
            console.log('[window.onload] Page fully loaded. Initial render will be triggered by onAuthStateChanged.');
            // Initial render is handled by onAuthStateChanged.
            // If no user is logged in, it will render the login screen.
            // If a user is logged in, it will fetch data and then render the main screen.
        };
    </script>
</body>
</html>
